<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Modules - ErlViz Documentation</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', sans-serif;
            line-height: 1.6;
            color: #333;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f8f9fa;
        }
        .container {
            background-color: white;
            padding: 30px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        h1, h2, h3, h4, h5, h6 {
            color: #2c3e50;
        }
        h1 {
            border-bottom: 2px solid #3498db;
            padding-bottom: 10px;
        }
        h2 {
            border-bottom: 1px solid #bdc3c7;
            padding-bottom: 5px;
            margin-top: 30px;
        }
        code {
            background-color: #f8f9fa;
            padding: 2px 6px;
            border-radius: 3px;
            font-family: 'Monaco', 'Consolas', monospace;
        }
        pre {
            background-color: #f8f9fa;
            padding: 15px;
            border-radius: 5px;
            overflow-x: auto;
            border-left: 4px solid #3498db;
        }
        table {
            border-collapse: collapse;
            width: 100%;
            margin: 15px 0;
        }
        th, td {
            border: 1px solid #ddd;
            padding: 12px;
            text-align: left;
        }
        th {
            background-color: #f2f2f2;
            font-weight: bold;
        }
        .toc {
            background-color: #f8f9fa;
            padding: 15px;
            border-radius: 5px;
            margin: 20px 0;
        }
        img {
            max-width: 100%;
            height: auto;
            border: 1px solid #ddd;
            border-radius: 5px;
            margin: 10px 0;
        }
        hr {
            border: none;
            height: 1px;
            background-color: #bdc3c7;
            margin: 30px 0;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1 id="module-documentation">Module Documentation</h1>
<h2 id="module-modules">Module Modules</h2>
<h3 id="cowboy">cowboy</h3>
<p><strong>File</strong>: <code>/Users/ddleon/.erlviz/cache/ninenines_cowboy/src/cowboy.erl</code></p>
<p><strong>Description</strong>:
Copyright (c) Loïc Hoguin <a href="&#109;&#97;&#105;&#108;&#116;&#111;&#58;&#101;&#115;&#115;&#101;&#110;&#64;&#110;&#105;&#110;&#101;&#110;&#105;&#110;&#101;&#115;&#46;&#101;&#117;">&#101;&#115;&#115;&#101;&#110;&#64;&#110;&#105;&#110;&#101;&#110;&#105;&#110;&#101;&#115;&#46;&#101;&#117;</a>
%% Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted, provided that the above
copyright notice and this permission notice appear in all copies.
%% THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF</p>
<p><strong>Exported Functions</strong>: start_clear/3, start_tls/3, start_quic/3, stop_listener/1, get_env/2, get_env/3, set_env/3, log/2, log/4</p>
<p><strong>Functions</strong>:</p>
<ul>
<li><code>start_clear(Ref, TransOpts0, ProtoOpts0)</code> - Copyright (c) Loïc Hoguin <a href="&#109;&#97;&#105;&#108;&#116;&#111;&#58;&#101;&#115;&#115;&#101;&#110;&#64;&#110;&#105;&#110;&#101;&#110;&#105;&#110;&#101;&#115;&#46;&#101;&#117;">&#101;&#115;&#115;&#101;&#110;&#64;&#110;&#105;&#110;&#101;&#110;&#105;&#110;&#101;&#115;&#46;&#101;&#117;</a>
%%
%% Permission to use, copy, modify, and/or distribute this software for any
%% purpose with or without fee is hereby granted, provided that the above
%% copyright notice and this permission notice appear in all copies.
%%
%% THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
%% WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
%% MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
%% ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
%% WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
%% ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
%% OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.</li>
</ul>
<p>-module(cowboy).</p>
<p>-export([start_clear/3]).
-export([start_tls/3]).
-export([start_quic/3]).
-export([stop_listener/1]).
-export([get_env/2]).
-export([get_env/3]).
-export([set_env/3]).</p>
<p>%% Internal.
-export([log/2]).
-export([log/4]).</p>
<p>%% Don't warn about the bad quicer specs.
-dialyzer([{nowarn_function, start_quic/3}]).</p>
<p>-type opts() :: cowboy_http:opts() | cowboy_http2:opts().
-export_type([opts/0]).</p>
<p>-type fields() :: [atom()
    | {atom(), cowboy_constraints:constraint() | [cowboy_constraints:constraint()]}
    | {atom(), cowboy_constraints:constraint() | [cowboy_constraints:constraint()], any()}].
-export_type([fields/0]).</p>
<p>-type http_headers() :: #{binary() =&gt; iodata()}.
-export_type([http_headers/0]).</p>
<p>-type http_status() :: non_neg_integer() | binary().
-export_type([http_status/0]).</p>
<p>-type http_version() :: 'HTTP/2' | 'HTTP/1.1' | 'HTTP/1.0'.
-export_type([http_version/0]).</p>
<p>-spec start_clear(ranch:ref(), ranch:opts(), opts())
    -&gt; {ok, pid()} | {error, any()}.
- <code>start_quic(Ref, TransOpts, ProtoOpts)</code> - @todo Experimental function to start a barebone QUIC listener.
%%       This will need to be reworked to be closer to Ranch
%%       listeners and provide equivalent features.
%%
%% @todo Better type for transport options. Might require fixing quicer types.</p>
<p>-spec start_quic(ranch:ref(), #{socket_opts =&gt; [{atom(), _}]}, cowboy_http3:opts())
    -&gt; {ok, pid()}.</p>
<p>%% @todo Implement dynamic_buffer for HTTP/3 if/when it applies.
- <code>port_0()</code> - @todo Why not binary?
        %% We only need 3 for control and QPACK enc/dec,
        %% but we need more for WebTransport. %% @todo Use 3 if WT is disabled.
        {peer_unidi_stream_count, 100},
        {peer_bidi_stream_count, 100},
        %% For WebTransport.
        %% @todo We probably don't want it enabled if WT isn't used.
        {datagram_send_enabled, 1},
        {datagram_receive_enabled, 1}
    |SocketOpts2],
    <em>ListenerPid = spawn(fun() -&gt;
        {ok, Listener} = quicer:listen(Port, SocketOpts),
        Parent ! {ok, Listener},
        _AcceptorPid = [spawn(fun AcceptLoop() -&gt;
            {ok, Conn} = quicer:accept(Listener, []),
            Pid = spawn(fun() -&gt;
                receive go -&gt; ok end,
                %% We have to do the handshake after handing control of
                %% the connection otherwise streams may come in before
                %% the controlling process is changed and messages will
                %% not be sent to the correct process.
                {ok, Conn} = quicer:handshake(Conn),
                process_flag(trap_exit, true), %% @todo Only if supervisor though.
                try cowboy_http3:init(Parent, Ref, Conn, ProtoOpts)
                catch
                    exit:{shutdown,</em>} -&gt; ok;
                    C:E:S -&gt; log(error, "CRASH ~p:~p:~p", [C,E,S], ProtoOpts)
                end
            end),
            ok = quicer:controlling_process(Conn, Pid),
            Pid ! go,
            AcceptLoop()
        end) || _ &lt;- lists:seq(1, 20)],
        %% Listener process must not terminate.
        receive after infinity -&gt; ok end
    end),
    receive
        {ok, Listener} -&gt;
            {ok, Listener}
    end.</p>
<p>%% Select a random UDP port using gen_udp because quicer
%% does not provide equivalent functionality. Taken from
%% quicer test suites.
- <code>ensure_alpn(TransOpts)</code> - Apparently macOS doesn't free the port immediately.
            timer:sleep(500);
        _ -&gt;
            ok
    end,
    Port.
- <code>ensure_dynamic_buffer(TransOpts=#{socket_opts := SocketOpts}, _)</code> - Dynamic buffer was not set; define default dynamic buffer
%% only if 'buffer' size was not configured. In that case we
%% set the 'buffer' size to the lowest value.
- <code>log(Level, Format, Args, _)</code> - We use error_logger by default. Because error_logger does
%% not have all the levels we accept we have to do some
%% mapping to error_logger functions.</p>
<p><strong>Dependencies</strong>: cowboy_http2, cowboy_constraints, cowboy_http, cowboy_http3</p>
<hr />
<h3 id="cowboy_bstr">cowboy_bstr</h3>
<p><strong>File</strong>: <code>/Users/ddleon/.erlviz/cache/ninenines_cowboy/src/cowboy_bstr.erl</code></p>
<p><strong>Description</strong>:
Copyright (c) Loïc Hoguin <a href="&#109;&#97;&#105;&#108;&#116;&#111;&#58;&#101;&#115;&#115;&#101;&#110;&#64;&#110;&#105;&#110;&#101;&#110;&#105;&#110;&#101;&#115;&#46;&#101;&#117;">&#101;&#115;&#115;&#101;&#110;&#64;&#110;&#105;&#110;&#101;&#110;&#105;&#110;&#101;&#115;&#46;&#101;&#117;</a>
%% Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted, provided that the above
copyright notice and this permission notice appear in all copies.
%% THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF</p>
<p><strong>Exported Functions</strong>: capitalize_token/1, to_lower/1, to_upper/1, char_to_lower/1, char_to_upper/1</p>
<p><strong>Functions</strong>:</p>
<ul>
<li><code>capitalize_token(B)</code> - Copyright (c) Loïc Hoguin <a href="&#109;&#97;&#105;&#108;&#116;&#111;&#58;&#101;&#115;&#115;&#101;&#110;&#64;&#110;&#105;&#110;&#101;&#110;&#105;&#110;&#101;&#115;&#46;&#101;&#117;">&#101;&#115;&#115;&#101;&#110;&#64;&#110;&#105;&#110;&#101;&#110;&#105;&#110;&#101;&#115;&#46;&#101;&#117;</a>
%%
%% Permission to use, copy, modify, and/or distribute this software for any
%% purpose with or without fee is hereby granted, provided that the above
%% copyright notice and this permission notice appear in all copies.
%%
%% THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
%% WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
%% MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
%% ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
%% WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
%% ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
%% OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.</li>
</ul>
<p>-module(cowboy_bstr).</p>
<p>%% Binary strings.
-export([capitalize_token/1]).
-export([to_lower/1]).
-export([to_upper/1]).</p>
<p>%% Characters.
-export([char_to_lower/1]).
-export([char_to_upper/1]).</p>
<p>%% The first letter and all letters after a dash are capitalized.
%% This is the form seen for header names in the HTTP/1.1 RFC and
%% others. Note that using this form isn't required, as header names
%% are case insensitive, and it is only provided for use with eventual
%% badly implemented clients.
-spec capitalize_token(B) -&gt; B when B::binary().
- <code>capitalize_token_test_()</code> - Tests.</p>
<p>-ifdef(TEST).</p>
<hr />
<h3 id="cowboy_children">cowboy_children</h3>
<p><strong>File</strong>: <code>/Users/ddleon/.erlviz/cache/ninenines_cowboy/src/cowboy_children.erl</code></p>
<p><strong>Description</strong>:
Copyright (c) Loïc Hoguin <a href="&#109;&#97;&#105;&#108;&#116;&#111;&#58;&#101;&#115;&#115;&#101;&#110;&#64;&#110;&#105;&#110;&#101;&#110;&#105;&#110;&#101;&#115;&#46;&#101;&#117;">&#101;&#115;&#115;&#101;&#110;&#64;&#110;&#105;&#110;&#101;&#110;&#105;&#110;&#101;&#115;&#46;&#101;&#117;</a>
%% Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted, provided that the above
copyright notice and this permission notice appear in all copies.
%% THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF</p>
<p><strong>Exported Functions</strong>: init/0, up/4, down/2, shutdown/2, shutdown_timeout/3, terminate/1, handle_supervisor_call/4</p>
<p><strong>Functions</strong>:</p>
<ul>
<li><code>init()</code> - Copyright (c) Loïc Hoguin <a href="&#109;&#97;&#105;&#108;&#116;&#111;&#58;&#101;&#115;&#115;&#101;&#110;&#64;&#110;&#105;&#110;&#101;&#110;&#105;&#110;&#101;&#115;&#46;&#101;&#117;">&#101;&#115;&#115;&#101;&#110;&#64;&#110;&#105;&#110;&#101;&#110;&#105;&#110;&#101;&#115;&#46;&#101;&#117;</a>
%%
%% Permission to use, copy, modify, and/or distribute this software for any
%% purpose with or without fee is hereby granted, provided that the above
%% copyright notice and this permission notice appear in all copies.
%%
%% THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
%% WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
%% MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
%% ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
%% WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
%% ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
%% OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.</li>
</ul>
<p>-module(cowboy_children).</p>
<p>-export([init/0]).
-export([up/4]).
-export([down/2]).
-export([shutdown/2]).
-export([shutdown_timeout/3]).
-export([terminate/1]).
-export([handle_supervisor_call/4]).</p>
<p>-record(child, {
    pid :: pid(),
    streamid :: cowboy_stream:streamid() | undefined,
    shutdown :: timeout(),
    timer = undefined :: undefined | reference()
}).</p>
<p>-type children() :: [#child{}].
-export_type([children/0]).</p>
<p>-spec init() -&gt; [].
- <code>shutdown(Children0, StreamID)</code> - We ask the processes to shutdown first. This gives
%% a chance to processes that are trapping exits to
%% shut down gracefully. Others will exit immediately.
%%
%% @todo We currently fire one timer per process being
%% shut down. This is probably not the most efficient.
%% A more efficient solution could be to maintain a
%% single timer and decrease the shutdown time of all
%% processes when it fires. This is however much more
%% complex, and there aren't that many processes that
%% will need to be shutdown through this function, so
%% this is left for later.
-spec shutdown(Children, cowboy_stream:streamid())
    -&gt; Children when Children::children().
- <code>before_terminate_loop([])</code> - For each child, either ask for it to shut down,
    %% or cancel its shutdown timer if it already is.
    %%
    %% We do not need to flush stray timeout messages out because
    %% we are either terminating or switching protocols,
    %% and in the latter case we flush all messages.
    _ = [case TRef of
        undefined -&gt; exit(Pid, shutdown);
        _ -&gt; erlang:cancel_timer(TRef, [{async, true}, {info, false}])
    end || #child{pid=Pid, timer=TRef} &lt;- Children],
    before_terminate_loop(Children).
- <code>terminate_loop(Children, TRef)</code> - Don't forget to cancel the timer, if any!
    case TRef of
        undefined -&gt;
            ok;
        _ -&gt;
            _ = erlang:cancel_timer(TRef, [{async, true}, {info, false}]),
            ok
    end;
- <code>longest_shutdown_time([], Time)</code> - We delayed the creation of the timer. If a process with
            %% infinity shutdown just ended, we might have to start that timer.
            case Shutdown of
                infinity -&gt; before_terminate_loop(Children1);
                _ -&gt; terminate_loop(Children1, TRef)
            end;
        {'EXIT', Pid, _} -&gt;
            terminate_loop(lists:keydelete(Pid, #child.pid, Children), TRef);
        {timeout, TRef, terminate} -&gt;
            %% Brutally kill any remaining children.
            _ = [exit(Pid, kill) || #child{pid=Pid} &lt;- Children],
            ok
    end.
- <code>handle_supervisor_call(_, {From, Tag}, _, _)</code> - All other calls refer to children. We act in a similar way
%% to a simple_one_for_one so we never find those.</p>
<p><strong>Dependencies</strong>: cowboy_stream</p>
<hr />
<h3 id="cowboy_clear">cowboy_clear</h3>
<p><strong>File</strong>: <code>/Users/ddleon/.erlviz/cache/ninenines_cowboy/src/cowboy_clear.erl</code></p>
<p><strong>Behaviors</strong>: ranch_protocol</p>
<p><strong>Description</strong>:
Copyright (c) Loïc Hoguin <a href="&#109;&#97;&#105;&#108;&#116;&#111;&#58;&#101;&#115;&#115;&#101;&#110;&#64;&#110;&#105;&#110;&#101;&#110;&#105;&#110;&#101;&#115;&#46;&#101;&#117;">&#101;&#115;&#115;&#101;&#110;&#64;&#110;&#105;&#110;&#101;&#110;&#105;&#110;&#101;&#115;&#46;&#101;&#117;</a>
%% Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted, provided that the above
copyright notice and this permission notice appear in all copies.
%% THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF</p>
<p><strong>Exported Functions</strong>: start_link/3, start_link/4, connection_process/4</p>
<p><strong>Functions</strong>:</p>
<ul>
<li><code>start_link(Ref, Transport, Opts)</code> - Ranch 2.
-spec start_link(ranch:ref(), module(), cowboy:opts()) -&gt; {ok, pid()}.</li>
<li><code>init(Parent, Ref, Socket, Transport, ProxyInfo, Opts, Protocol)</code> - Use cowboy_http2 directly only when 'http' is missing.
    Protocol = case maps:get(protocols, Opts, [http2, http]) of
        [http2] -&gt; cowboy_http2;
        [<em>|</em>] -&gt; cowboy_http
    end,
    init(Parent, Ref, Socket, Transport, ProxyInfo, Opts, Protocol).</li>
</ul>
<p><strong>Dependencies</strong>: cowboy</p>
<hr />
<h3 id="cowboy_compress_h">cowboy_compress_h</h3>
<p><strong>File</strong>: <code>/Users/ddleon/.erlviz/cache/ninenines_cowboy/src/cowboy_compress_h.erl</code></p>
<p><strong>Behaviors</strong>: cowboy_stream</p>
<p><strong>Description</strong>:
Copyright (c) Loïc Hoguin <a href="&#109;&#97;&#105;&#108;&#116;&#111;&#58;&#101;&#115;&#115;&#101;&#110;&#64;&#110;&#105;&#110;&#101;&#110;&#105;&#110;&#101;&#115;&#46;&#101;&#117;">&#101;&#115;&#115;&#101;&#110;&#64;&#110;&#105;&#110;&#101;&#110;&#105;&#110;&#101;&#115;&#46;&#101;&#117;</a>
%% Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted, provided that the above
copyright notice and this permission notice appear in all copies.
%% THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF</p>
<p><strong>Exported Functions</strong>: init/3, data/4, info/3, terminate/3, early_error/5</p>
<p><strong>Functions</strong>:</p>
<ul>
<li><code>init(StreamID, Req, Opts)</code> - Copyright (c) Loïc Hoguin <a href="&#109;&#97;&#105;&#108;&#116;&#111;&#58;&#101;&#115;&#115;&#101;&#110;&#64;&#110;&#105;&#110;&#101;&#110;&#105;&#110;&#101;&#115;&#46;&#101;&#117;">&#101;&#115;&#115;&#101;&#110;&#64;&#110;&#105;&#110;&#101;&#110;&#105;&#110;&#101;&#115;&#46;&#101;&#117;</a>
%%
%% Permission to use, copy, modify, and/or distribute this software for any
%% purpose with or without fee is hereby granted, provided that the above
%% copyright notice and this permission notice appear in all copies.
%%
%% THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
%% WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
%% MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
%% ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
%% WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
%% ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
%% OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.</li>
</ul>
<p>-module(cowboy_compress_h).
-behavior(cowboy_stream).</p>
<p>-export([init/3]).
-export([data/4]).
-export([info/3]).
-export([terminate/3]).
-export([early_error/5]).</p>
<p>-record(state, {
    next :: any(),
    threshold :: non_neg_integer() | undefined,
    compress = undefined :: undefined | gzip,
    deflate = undefined :: undefined | zlib:zstream(),
    deflate_flush = sync :: none | sync
}).</p>
<p>-spec init(cowboy_stream:streamid(), cowboy_req:req(), cowboy:opts())
    -&gt; {cowboy_stream:commands(), #state{}}.
- <code>early_error(StreamID, Reason, PartialReq, Resp, Opts)</code> - Clean the zlib:stream() in case something went wrong.
    %% In the normal scenario the stream is already closed.
    case Z of
        undefined -&gt; ok;
        _ -&gt; zlib:close(Z)
    end,
    cowboy_stream:terminate(StreamID, Reason, Next).</p>
<p>-spec early_error(cowboy_stream:streamid(), cowboy_stream:reason(),
    cowboy_stream:partial_req(), Resp, cowboy:opts()) -&gt; Resp
    when Resp::cowboy_stream:resp_command().
- <code>check_req(Req)</code> - Internal.</p>
<p>%% Check if the client supports decoding of gzip responses.
%%
%% A malformed accept-encoding header is ignored (no compression).
- <code>check_resp_headers(#{&lt;&lt;"etag"&gt;&gt; := _}, State)</code> - Do not compress responses that contain the etag header.
- <code>fold([Command|Tail], State, Acc)</code> - Otherwise, we have an unrelated command or compression is disabled.
- <code>gzip_headers({headers, Status, Headers0}, State)</code> - We can't call zlib:gzip/1 because it does an
    %% iolist_to_binary(GzBody) at the end to return
    %% a binary(). Therefore the code here is largely
    %% a duplicate of the code of that function.
    Z = zlib:open(),
    GzBody = try
        %% 31 = 16+?MAX_WBITS from zlib.erl
        %% @todo It might be good to allow them to be configured?
        zlib:deflateInit(Z, default, deflated, 31, 8, default),
        Gz = zlib:deflate(Z, Body, finish),
        zlib:deflateEnd(Z),
        Gz
    after
        zlib:close(Z)
    end,
    {{response, Status, Headers#{
        &lt;&lt;"content-length"&gt;&gt; =&gt; integer_to_binary(iolist_size(GzBody)),
        &lt;&lt;"content-encoding"&gt;&gt; =&gt; &lt;&lt;"gzip"&gt;&gt;
    }, GzBody}, State}.
- <code>vary_response({response, Status, Headers, Body})</code> - We use the same arguments as when compressing the body fully.
    %% @todo It might be good to allow them to be configured?
    zlib:deflateInit(Z, default, deflated, 31, 8, default),
    Headers = maps:remove(&lt;&lt;"content-length"&gt;&gt;, Headers0),
    {{headers, Status, Headers#{
        &lt;&lt;"content-encoding"&gt;&gt; =&gt; &lt;&lt;"gzip"&gt;&gt;
    }}, State#state{deflate=Z}}.
- <code>vary(Headers)</code> - The vary header is invalid. Probably empty. We replace it with ours.
        Headers#{&lt;&lt;"vary"&gt;&gt; =&gt; &lt;&lt;"accept-encoding"&gt;&gt;}
    end;
- <code>gzip_data({data, nofin, Sendfile={sendfile, _, _, _}},
        State=#state{deflate=Z, deflate_flush=Flush})</code> - It is not possible to combine zlib and the sendfile
%% syscall as far as I can tell, because the zlib format
%% includes a checksum at the end of the stream. We have
%% to read the file in memory, making this not suitable for
%% large files.</p>
<p><strong>Dependencies</strong>: cowboy, cowboy_stream, cowboy_req</p>
<hr />
<h3 id="cowboy_constraints">cowboy_constraints</h3>
<p><strong>File</strong>: <code>/Users/ddleon/.erlviz/cache/ninenines_cowboy/src/cowboy_constraints.erl</code></p>
<p><strong>Description</strong>:
Copyright (c) Loïc Hoguin <a href="&#109;&#97;&#105;&#108;&#116;&#111;&#58;&#101;&#115;&#115;&#101;&#110;&#64;&#110;&#105;&#110;&#101;&#110;&#105;&#110;&#101;&#115;&#46;&#101;&#117;">&#101;&#115;&#115;&#101;&#110;&#64;&#110;&#105;&#110;&#101;&#110;&#105;&#110;&#101;&#115;&#46;&#101;&#117;</a>
%% Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted, provided that the above
copyright notice and this permission notice appear in all copies.
%% THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF</p>
<p><strong>Exported Functions</strong>: validate/2, reverse/2, format_error/1</p>
<p><strong>Functions</strong>:</p>
<ul>
<li><code>validate(Value, Constraints) when is_list(Constraints)</code> - Copyright (c) Loïc Hoguin <a href="&#109;&#97;&#105;&#108;&#116;&#111;&#58;&#101;&#115;&#115;&#101;&#110;&#64;&#110;&#105;&#110;&#101;&#110;&#105;&#110;&#101;&#115;&#46;&#101;&#117;">&#101;&#115;&#115;&#101;&#110;&#64;&#110;&#105;&#110;&#101;&#110;&#105;&#110;&#101;&#115;&#46;&#101;&#117;</a>
%%
%% Permission to use, copy, modify, and/or distribute this software for any
%% purpose with or without fee is hereby granted, provided that the above
%% copyright notice and this permission notice appear in all copies.
%%
%% THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
%% WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
%% MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
%% ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
%% WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
%% ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
%% OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.</li>
</ul>
<p>-module(cowboy_constraints).</p>
<p>-export([validate/2]).
-export([reverse/2]).
-export([format_error/1]).</p>
<p>-type constraint() :: int | nonempty | fun().
-export_type([constraint/0]).</p>
<p>-type reason() :: {constraint(), any(), any()}.
-export_type([reason/0]).</p>
<p>-spec validate(binary(), constraint() | [constraint()])
    -&gt; {ok, any()} | {error, reason()}.
- <code>apply_constraint(Type, Value, int)</code> - @todo {int, From, To}, etc.
- <code>int(forward, Value)</code> - Constraint functions.
- <code>reverse_test()</code> - Value, Constraints, Result.
    Tests = [
        {&lt;&lt;&gt;&gt;, [], &lt;&lt;&gt;&gt;},
        {&lt;&lt;"123"&gt;&gt;, int, 123},
        {&lt;&lt;"123"&gt;&gt;, [int], 123},
        {&lt;&lt;"123"&gt;&gt;, [nonempty, int], 123},
        {&lt;&lt;"123"&gt;&gt;, [int, nonempty], 123},
        {&lt;&lt;&gt;&gt;, nonempty, error},
        {&lt;&lt;&gt;&gt;, [nonempty], error},
        {&lt;&lt;"hello"&gt;&gt;, F, hello},
        {&lt;&lt;"hello"&gt;&gt;, [F], hello},
        {&lt;&lt;"123"&gt;&gt;, [F, int], error},
        {&lt;&lt;"123"&gt;&gt;, [int, F], error},
        {&lt;&lt;"hello"&gt;&gt;, [nonempty, F], hello},
        {&lt;&lt;"hello"&gt;&gt;, [F, nonempty], hello}
    ],
    [{lists:flatten(io_lib:format("~p, ~p", [V, C])), fun() -&gt;
        case R of
            error -&gt; {error, <em>} = validate(V, C);
            _ -&gt; {ok, R} = validate(V, C)
        end
    end} || {V, C, R} &lt;- Tests].
- <code>int_format_error_test()</code> - Value, Constraints, Result.
    Tests = [
        {&lt;&lt;&gt;&gt;, [], &lt;&lt;&gt;&gt;},
        {123, int, &lt;&lt;"123"&gt;&gt;},
        {123, [int], &lt;&lt;"123"&gt;&gt;},
        {123, [nonempty, int], &lt;&lt;"123"&gt;&gt;},
        {123, [int, nonempty], &lt;&lt;"123"&gt;&gt;},
        {&lt;&lt;&gt;&gt;, nonempty, error},
        {&lt;&lt;&gt;&gt;, [nonempty], error},
        {hello, F, &lt;&lt;"hello"&gt;&gt;},
        {hello, [F], &lt;&lt;"hello"&gt;&gt;},
        {123, [F, int], error},
        {123, [int, F], error},
        {hello, [nonempty, F], &lt;&lt;"hello"&gt;&gt;},
        {hello, [F, nonempty], &lt;&lt;"hello"&gt;&gt;}
    ],
    [{lists:flatten(io_lib:format("~p, ~p", [V, C])), fun() -&gt;
        case R of
            error -&gt; {error, </em>} = reverse(V, C);
            _ -&gt; {ok, R} = reverse(V, C)
        end
    end} || {V, C, R} &lt;- Tests].</p>
<hr />
<h3 id="cowboy_decompress_h">cowboy_decompress_h</h3>
<p><strong>File</strong>: <code>/Users/ddleon/.erlviz/cache/ninenines_cowboy/src/cowboy_decompress_h.erl</code></p>
<p><strong>Behaviors</strong>: cowboy_stream</p>
<p><strong>Description</strong>:
Copyright (c) jdamanalo <a href="&#109;&#97;&#105;&#108;&#116;&#111;&#58;&#106;&#111;&#115;&#104;&#117;&#97;&#100;&#97;&#118;&#105;&#100;&#46;&#97;&#103;&#117;&#115;&#116;&#105;&#110;&#64;&#109;&#97;&#110;&#97;&#108;&#111;&#46;&#112;&#104;">&#106;&#111;&#115;&#104;&#117;&#97;&#100;&#97;&#118;&#105;&#100;&#46;&#97;&#103;&#117;&#115;&#116;&#105;&#110;&#64;&#109;&#97;&#110;&#97;&#108;&#111;&#46;&#112;&#104;</a>
Copyright (c) Loïc Hoguin <a href="&#109;&#97;&#105;&#108;&#116;&#111;&#58;&#101;&#115;&#115;&#101;&#110;&#64;&#110;&#105;&#110;&#101;&#110;&#105;&#110;&#101;&#115;&#46;&#101;&#117;">&#101;&#115;&#115;&#101;&#110;&#64;&#110;&#105;&#110;&#101;&#110;&#105;&#110;&#101;&#115;&#46;&#101;&#117;</a>
%% Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted, provided that the above
copyright notice and this permission notice appear in all copies.
%% THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN</p>
<p><strong>Exported Functions</strong>: init/3, data/4, info/3, terminate/3, early_error/5</p>
<p><strong>Functions</strong>:</p>
<ul>
<li><code>init(StreamID, Req0, Opts)</code> - Copyright (c) jdamanalo <a href="&#109;&#97;&#105;&#108;&#116;&#111;&#58;&#106;&#111;&#115;&#104;&#117;&#97;&#100;&#97;&#118;&#105;&#100;&#46;&#97;&#103;&#117;&#115;&#116;&#105;&#110;&#64;&#109;&#97;&#110;&#97;&#108;&#111;&#46;&#112;&#104;">&#106;&#111;&#115;&#104;&#117;&#97;&#100;&#97;&#118;&#105;&#100;&#46;&#97;&#103;&#117;&#115;&#116;&#105;&#110;&#64;&#109;&#97;&#110;&#97;&#108;&#111;&#46;&#112;&#104;</a>
%% Copyright (c) Loïc Hoguin <a href="&#109;&#97;&#105;&#108;&#116;&#111;&#58;&#101;&#115;&#115;&#101;&#110;&#64;&#110;&#105;&#110;&#101;&#110;&#105;&#110;&#101;&#115;&#46;&#101;&#117;">&#101;&#115;&#115;&#101;&#110;&#64;&#110;&#105;&#110;&#101;&#110;&#105;&#110;&#101;&#115;&#46;&#101;&#117;</a>
%%
%% Permission to use, copy, modify, and/or distribute this software for any
%% purpose with or without fee is hereby granted, provided that the above
%% copyright notice and this permission notice appear in all copies.
%%
%% THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
%% WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
%% MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
%% ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
%% WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
%% ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
%% OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.</li>
</ul>
<p>-module(cowboy_decompress_h).
-behavior(cowboy_stream).</p>
<p>-export([init/3]).
-export([data/4]).
-export([info/3]).
-export([terminate/3]).
-export([early_error/5]).</p>
<p>-record(state, {
    next :: any(),
    enabled = true :: boolean(),
    ratio_limit :: non_neg_integer() | undefined,
    compress = undefined :: undefined | gzip,
    inflate = undefined :: undefined | zlib:zstream(),
    is_reading = false :: boolean(),</p>
<div class="codehilite"><pre><span></span><code><span class="c">%% We use a list of binaries to avoid doing unnecessary</span>
<span class="c">%% memory allocations when inflating. We convert to binary</span>
<span class="c">%% when we propagate the data. The data must be reversed</span>
<span class="c">%% before converting to binary or inflating: this is done</span>
<span class="c">%% via the buffer_to_binary/buffer_to_iovec functions.</span>
<span class="n">read_body_buffer</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="p">[]</span><span class="w"> </span><span class="p">::</span><span class="w"> </span><span class="p">[</span><span class="nb">binary</span><span class="p">()],</span>
<span class="n">read_body_is_fin</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="n">nofin</span><span class="w"> </span><span class="p">::</span><span class="w"> </span><span class="n">nofin</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="p">{</span><span class="n">fin</span><span class="p">,</span><span class="w"> </span><span class="n">non_neg_integer</span><span class="p">()}</span>
</code></pre></div>

<p>}).</p>
<p>-spec init(cowboy_stream:streamid(), cowboy_req:req(), cowboy:opts())
    -&gt; {cowboy_stream:commands(), #state{}}.
- <code>info(StreamID, Info, State=#state{next=Next0})</code> - We can't change the enabled setting after we start reading,
    %% otherwise the data becomes garbage. Changing the setting
    %% is not treated as an error, it is just ignored.
    State = case IsReading of
        true -&gt; State0;
        false -&gt; State0#state{enabled=Enabled}
    end,
    fold(Commands, State#state{next=Next, ratio_limit=RatioLimit});
- <code>check_and_update_req(Req=#{headers := Headers})</code> - Internal.</p>
<p>%% Check whether the request needs content decoding, and if it does
%% whether it fits our criteria for decoding. We also update the
%% Req to indicate whether content was decoded.
%%
%% We always set the content_decoded value in the Req because it
%% indicates whether content decoding was attempted.
%%
%% A malformed content-encoding header results in no decoding.
- <code>buffer_to_iovec(Buffer)</code> - We only automatically decompress when gzip is the only
        %% encoding used. Since it's the only encoding used, we
        %% can remove the header entirely before passing the Req
        %% forward.
        [&lt;&lt;"gzip"&gt;&gt;] -&gt;
            {Req#{
                headers =&gt; maps:remove(&lt;&lt;"content-encoding"&gt;&gt;, Headers),
                content_decoded =&gt; [&lt;&lt;"gzip"&gt;&gt;|ContentDecoded]
            }, #state{compress=gzip}};
        _ -&gt;
            {Req#{content_decoded =&gt; ContentDecoded},
                #state{compress=undefined}}
    catch <em>:</em> -&gt;
        {Req#{content_decoded =&gt; ContentDecoded},
            #state{compress=undefined}}
    end.
- <code>add_accept_encoding(Headers)</code> - gzip is excluded but this handler is enabled; we replace.
                {<em>, 0} -&gt;
                    Replaced = lists:keyreplace(&lt;&lt;"gzip"&gt;&gt;, 1, List, {&lt;&lt;"gzip"&gt;&gt;, 1000}),
                    Codings = build_accept_encoding(Replaced),
                    Headers#{&lt;&lt;"accept-encoding"&gt;&gt; =&gt; Codings};
                {</em>, <em>} -&gt;
                    Headers;
                false -&gt;
                    case lists:keyfind(&lt;&lt;"*"&gt;&gt;, 1, List) of
                        %% Others are excluded along with gzip; we add.
                        {</em>, 0} -&gt;
                            WithGzip = [{&lt;&lt;"gzip"&gt;&gt;, 1000} | List],
                            Codings = build_accept_encoding(WithGzip),
                            Headers#{&lt;&lt;"accept-encoding"&gt;&gt; =&gt; Codings};
                        {<em>, </em>} -&gt;
                            Headers;
                        false -&gt;
                            Headers#{&lt;&lt;"accept-encoding"&gt;&gt; =&gt; [AcceptEncoding, &lt;&lt;", gzip"&gt;&gt;]}
                    end
            end
    catch <em>:</em> -&gt;
        %% The accept-encoding header is invalid. Probably empty. We replace it with ours.
        Headers#{&lt;&lt;"accept-encoding"&gt;&gt; =&gt; &lt;&lt;"gzip"&gt;&gt;}
    end;
- <code>qvalue_to_iodata(0)</code> - @todo From cowlib, maybe expose?
- <code>build_accept_encoding([{ContentCoding, Q}|Tail])</code> - @todo Should be added to Cowlib.</p>
<p><strong>Dependencies</strong>: cowboy, cowboy_stream, cowboy_req</p>
<hr />
<h3 id="cowboy_handler">cowboy_handler</h3>
<p><strong>File</strong>: <code>/Users/ddleon/.erlviz/cache/ninenines_cowboy/src/cowboy_handler.erl</code></p>
<p><strong>Behaviors</strong>: cowboy_middleware</p>
<p><strong>Description</strong>:
Copyright (c) Loïc Hoguin <a href="&#109;&#97;&#105;&#108;&#116;&#111;&#58;&#101;&#115;&#115;&#101;&#110;&#64;&#110;&#105;&#110;&#101;&#110;&#105;&#110;&#101;&#115;&#46;&#101;&#117;">&#101;&#115;&#115;&#101;&#110;&#64;&#110;&#105;&#110;&#101;&#110;&#105;&#110;&#101;&#115;&#46;&#101;&#117;</a>
%% Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted, provided that the above
copyright notice and this permission notice appear in all copies.
%% THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF</p>
<p><strong>Exported Functions</strong>: execute/2, terminate/4</p>
<p><strong>Functions</strong>:</p>
<ul>
<li><code>execute(Req, Env=#{handler := Handler, handler_opts := HandlerOpts})</code> - Copyright (c) Loïc Hoguin <a href="&#109;&#97;&#105;&#108;&#116;&#111;&#58;&#101;&#115;&#115;&#101;&#110;&#64;&#110;&#105;&#110;&#101;&#110;&#105;&#110;&#101;&#115;&#46;&#101;&#117;">&#101;&#115;&#115;&#101;&#110;&#64;&#110;&#105;&#110;&#101;&#110;&#105;&#110;&#101;&#115;&#46;&#101;&#117;</a>
%%
%% Permission to use, copy, modify, and/or distribute this software for any
%% purpose with or without fee is hereby granted, provided that the above
%% copyright notice and this permission notice appear in all copies.
%%
%% THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
%% WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
%% MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
%% ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
%% WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
%% ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
%% OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.</li>
</ul>
<p>%% Handler middleware.
%%
%% Execute the handler given by the <em>handler</em> and <em>handler_opts</em>
%% environment values. The result of this execution is added to the
%% environment under the <em>result</em> value.
-module(cowboy_handler).
-behaviour(cowboy_middleware).</p>
<p>-export([execute/2]).
-export([terminate/4]).</p>
<p>-callback init(Req, any())
    -&gt; {ok | module(), Req, any()}
    | {module(), Req, any(), any()}
    when Req::cowboy_req:req().</p>
<p>-callback terminate(any(), map(), any()) -&gt; ok.
-optional_callbacks([terminate/3]).</p>
<p>-spec execute(Req, Env) -&gt; {ok, Req, Env}
    when Req::cowboy_req:req(), Env::cowboy_middleware:env().</p>
<p><strong>Dependencies</strong>: cowboy_req, cowboy_middleware</p>
<hr />
<h3 id="cowboy_http">cowboy_http</h3>
<p><strong>File</strong>: <code>/Users/ddleon/.erlviz/cache/ninenines_cowboy/src/cowboy_http.erl</code></p>
<p><strong>Description</strong>:
Copyright (c) Loïc Hoguin <a href="&#109;&#97;&#105;&#108;&#116;&#111;&#58;&#101;&#115;&#115;&#101;&#110;&#64;&#110;&#105;&#110;&#101;&#110;&#105;&#110;&#101;&#115;&#46;&#101;&#117;">&#101;&#115;&#115;&#101;&#110;&#64;&#110;&#105;&#110;&#101;&#110;&#105;&#110;&#101;&#115;&#46;&#101;&#117;</a>
%% Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted, provided that the above
copyright notice and this permission notice appear in all copies.
%% THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF</p>
<p><strong>Exported Functions</strong>: init/6, loop/1, system_continue/3, system_terminate/4, system_code_change/4</p>
<p><strong>Functions</strong>:</p>
<ul>
<li><code>init(Parent, Ref, Socket, Transport, ProxyHeader, Opts)</code> - Copyright (c) Loïc Hoguin <a href="&#109;&#97;&#105;&#108;&#116;&#111;&#58;&#101;&#115;&#115;&#101;&#110;&#64;&#110;&#105;&#110;&#101;&#110;&#105;&#110;&#101;&#115;&#46;&#101;&#117;">&#101;&#115;&#115;&#101;&#110;&#64;&#110;&#105;&#110;&#101;&#110;&#105;&#110;&#101;&#115;&#46;&#101;&#117;</a>
%%
%% Permission to use, copy, modify, and/or distribute this software for any
%% purpose with or without fee is hereby granted, provided that the above
%% copyright notice and this permission notice appear in all copies.
%%
%% THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
%% WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
%% MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
%% ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
%% WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
%% ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
%% OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.</li>
</ul>
<p>%% @todo Worth renaming to cowboy_http1.
%% @todo Change use of cow_http to cow_http1 where appropriate.
-module(cowboy_http).</p>
<p>-export([init/6]).
-export([loop/1]).</p>
<p>-export([system_continue/3]).
-export([system_terminate/4]).
-export([system_code_change/4]).</p>
<p>-type opts() :: #{
    active_n =&gt; pos_integer(),
    alpn_default_protocol =&gt; http | http2,
    chunked =&gt; boolean(),
    compress_buffering =&gt; boolean(),
    compress_threshold =&gt; non_neg_integer(),
    connection_type =&gt; worker | supervisor,
    dynamic_buffer =&gt; false | {pos_integer(), pos_integer()},
    dynamic_buffer_initial_average =&gt; non_neg_integer(),
    dynamic_buffer_initial_size =&gt; pos_integer(),
    env =&gt; cowboy_middleware:env(),
    hibernate =&gt; boolean(),
    http10_keepalive =&gt; boolean(),
    idle_timeout =&gt; timeout(),
    inactivity_timeout =&gt; timeout(),
    initial_stream_flow_size =&gt; non_neg_integer(),
    linger_timeout =&gt; timeout(),
    logger =&gt; module(),
    max_authority_length =&gt; non_neg_integer(),
    max_empty_lines =&gt; non_neg_integer(),
    max_header_name_length =&gt; non_neg_integer(),
    max_header_value_length =&gt; non_neg_integer(),
    max_headers =&gt; non_neg_integer(),
    max_keepalive =&gt; non_neg_integer(),
    max_method_length =&gt; non_neg_integer(),
    max_request_line_length =&gt; non_neg_integer(),
    metrics_callback =&gt; cowboy_metrics_h:metrics_callback(),
    metrics_req_filter =&gt; fun((cowboy_req:req()) -&gt; map()),
    metrics_resp_headers_filter =&gt; fun((cowboy:http_headers()) -&gt; cowboy:http_headers()),
    middlewares =&gt; [module()],
    protocols =&gt; [http | http2],
    proxy_header =&gt; boolean(),
    request_timeout =&gt; timeout(),
    reset_idle_timeout_on_send =&gt; boolean(),
    sendfile =&gt; boolean(),
    shutdown_timeout =&gt; timeout(),
    stream_handlers =&gt; [module()],
    tracer_callback =&gt; cowboy_tracer_h:tracer_callback(),
    tracer_flags =&gt; [atom()],
    tracer_match_specs =&gt; cowboy_tracer_h:tracer_match_specs(),
    %% Open ended because configured stream handlers might add options.
    _ =&gt; _
}.
-export_type([opts/0]).</p>
<p>-record(ps_request_line, {
    empty_lines = 0 :: non_neg_integer()
}).</p>
<p>-record(ps_header, {
    method = undefined :: binary(),
    authority = undefined :: binary() | undefined,
    path = undefined :: binary(),
    qs = undefined :: binary(),
    version = undefined :: cowboy:http_version(),
    headers = undefined :: cowboy:http_headers() | undefined,
    name = undefined :: binary() | undefined
}).</p>
<p>-record(ps_body, {
    length :: non_neg_integer() | undefined,
    received = 0 :: non_neg_integer(),
    transfer_decode_fun :: fun((binary(), cow_http_te:state()) -&gt; cow_http_te:decode_ret()),
    transfer_decode_state :: cow_http_te:state()
}).</p>
<p>-record(stream, {
    id = undefined :: cowboy_stream:streamid(),
    %% Stream handlers and their state.
    state = undefined :: {module(), any()},
    %% Request method.
    method = undefined :: binary(),
    %% Client HTTP version for this stream.
    version = undefined :: cowboy:http_version(),
    %% Unparsed te header. Used to know if we can send trailers.
    te :: undefined | binary(),
    %% Expected body size.
    local_expected_size = undefined :: undefined | non_neg_integer(),
    %% Sent body size.
    local_sent_size = 0 :: non_neg_integer(),
    %% Commands queued.
    queue = [] :: cowboy_stream:commands()
}).</p>
<p>-type stream() :: #stream{}.</p>
<p>-record(state, {
    parent :: pid(),
    ref :: ranch:ref(),
    socket :: inet:socket(),
    transport :: module(),
    proxy_header :: undefined | ranch_proxy_header:proxy_info(),
    opts = #{} :: cowboy:opts(),
    buffer = &lt;&lt;&gt;&gt; :: binary(),</p>
<div class="codehilite"><pre><span></span><code><span class="c">%% Some options may be overriden for the current stream.</span>
<span class="n">overriden_opts</span><span class="w"> </span><span class="p">=</span><span class="w"> </span>#<span class="p">{}</span><span class="w"> </span><span class="p">::</span><span class="w"> </span><span class="n">cowboy</span><span class="p">:</span><span class="n">opts</span><span class="p">(),</span>

<span class="c">%% Remote address and port for the connection.</span>
<span class="n">peer</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="n">undefined</span><span class="w"> </span><span class="p">::</span><span class="w"> </span><span class="p">{</span><span class="n">inet</span><span class="p">:</span><span class="n">ip_address</span><span class="p">(),</span><span class="w"> </span><span class="n">inet</span><span class="p">:</span><span class="n">port_number</span><span class="p">()},</span>

<span class="c">%% Local address and port for the connection.</span>
<span class="n">sock</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="n">undefined</span><span class="w"> </span><span class="p">::</span><span class="w"> </span><span class="p">{</span><span class="n">inet</span><span class="p">:</span><span class="n">ip_address</span><span class="p">(),</span><span class="w"> </span><span class="n">inet</span><span class="p">:</span><span class="n">port_number</span><span class="p">()},</span>

<span class="c">%% Client certificate (TLS only).</span>
<span class="n">cert</span><span class="w"> </span><span class="s">::</span><span class="w"> </span><span class="s">undefined</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="nb">binary</span><span class="p">(),</span>

<span class="nb">timer</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="n">undefined</span><span class="w"> </span><span class="p">::</span><span class="w"> </span><span class="n">undefined</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">reference</span><span class="p">(),</span>

<span class="c">%% Whether we are currently receiving data from the socket.</span>
<span class="n">active</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nb">true</span><span class="w"> </span><span class="p">::</span><span class="w"> </span><span class="n">boolean</span><span class="p">(),</span>

<span class="c">%% Identifier for the stream currently being read (or waiting to be received).</span>
<span class="n">in_streamid</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="p">::</span><span class="w"> </span><span class="n">pos_integer</span><span class="p">(),</span>

<span class="c">%% Parsing state for the current stream or stream-to-be.</span>
<span class="n">in_state</span><span class="w"> </span><span class="p">=</span><span class="w"> </span>#<span class="n">ps_request_line</span><span class="p">{}</span><span class="w"> </span><span class="p">::</span><span class="w"> </span>#<span class="n">ps_request_line</span><span class="p">{}</span><span class="w"> </span><span class="o">|</span><span class="w"> </span>#<span class="n">ps_header</span><span class="p">{}</span><span class="w"> </span><span class="o">|</span><span class="w"> </span>#<span class="n">ps_body</span><span class="p">{},</span>

<span class="c">%% Flow requested for the current stream.</span>
<span class="nb">flow</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="n">infinity</span><span class="w"> </span><span class="p">::</span><span class="w"> </span><span class="n">non_neg_integer</span><span class="p">()</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">infinity</span><span class="p">,</span>

<span class="c">%% Dynamic buffer moving average and current buffer size.</span>
<span class="n">dynamic_buffer_size</span><span class="w"> </span><span class="s">::</span><span class="w"> </span><span class="s">pos_integer()</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="nb">false</span><span class="p">,</span>
<span class="n">dynamic_buffer_moving_average</span><span class="w"> </span><span class="s">::</span><span class="w"> </span><span class="s">non_neg_integer(),</span>

<span class="c">%% Identifier for the stream currently being written.</span>
<span class="c">%% Note that out_streamid =&lt; in_streamid.</span>
<span class="n">out_streamid</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="p">::</span><span class="w"> </span><span class="n">pos_integer</span><span class="p">(),</span>

<span class="c">%% Whether we finished writing data for the current stream.</span>
<span class="n">out_state</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nb">wait</span><span class="w"> </span><span class="p">::</span><span class="w"> </span><span class="nb">wait</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">chunked</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">streaming</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">done</span><span class="p">,</span>

<span class="c">%% The connection will be closed after this stream.</span>
<span class="n">last_streamid</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="n">undefined</span><span class="w"> </span><span class="p">::</span><span class="w"> </span><span class="n">pos_integer</span><span class="p">(),</span>

<span class="c">%% Currently active HTTP/1.1 streams.</span>
<span class="n">streams</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="p">[]</span><span class="w"> </span><span class="p">::</span><span class="w"> </span><span class="p">[</span><span class="n">stream</span><span class="p">()],</span>

<span class="c">%% Children processes created by streams.</span>
<span class="n">children</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="n">cowboy_children</span><span class="p">:</span><span class="n">init</span><span class="p">()</span><span class="w"> </span><span class="p">::</span><span class="w"> </span><span class="n">cowboy_children</span><span class="p">:</span><span class="n">children</span><span class="p">()</span>
</code></pre></div>

<p>}).</p>
<p>-include_lib("cowlib/include/cow_inline.hrl").
-include_lib("cowlib/include/cow_parse.hrl").</p>
<p>-spec init(pid(), ranch:ref(), inet:socket(), module(),
    ranch_proxy_header:proxy_info(), cowboy:opts()) -&gt; ok.
- <code>before_loop(State=#state{opts=#{hibernate := true}})</code> - Hardcoded for compatibility with Ranch 1.x.
                Passive =:= tcp_passive; Passive =:= ssl_passive -&gt;
            flush_passive(Socket, Messages)
    after 0 -&gt;
        ok
    end.
- <code>set_timeout(State=#state{streams=[], in_state=InState}, idle_timeout)
        when element(1, InState) =/= ps_body -&gt;
    State;
%% Otherwise we can set the timeout.
%% @todo Don't do this so often, use a strategy similar to Websocket/H2 if possible.
set_timeout(State0=#state{opts=Opts, overriden_opts=Override}, Name)</code> - We do not set idle_timeout if there are no active streams,
%% unless when we are skipping a body.
- <code>maybe_reset_idle_timeout(State=#state{opts=Opts})</code> - The timeout may have been overriden for the current stream.
        #{Name := Timeout0} -&gt; Timeout0;
        _ -&gt; maps:get(Name, Opts, Default)
    end,
    TimerRef = case Timeout of
        infinity -&gt; undefined;
        Timeout -&gt; erlang:start_timer(Timeout, self(), Name)
    end,
    State#state{timer=TimerRef}.
- <code>timeout(State=#state{in_state=#ps_request_line{}}, request_timeout)</code> - Do a synchronous cancel and remove the message if any
            %% to avoid receiving stray messages.
            _ = erlang:cancel_timer(TimerRef, [{async, false}, {info, false}]),
            receive
                {timeout, TimerRef, _} -&gt; ok
            after 0 -&gt;
                ok
            end
    end,
    State#state{timer=undefined}.</p>
<p>-spec timeout(<em>, </em>) -&gt; no_return().
- <code>parse(_, State=#state{in_streamid=InStreamID, in_state=#ps_request_line{},
        last_streamid=LastStreamID}) when InStreamID &gt; LastStreamID -&gt;
    before_loop(State#state{buffer= &lt;&lt;&gt;&gt;});
parse(Buffer, State=#state{in_state=#ps_request_line{empty_lines=EmptyLines}})</code> - Do not process requests that come in after the last request
%% and discard the buffer if any to save memory.
- <code>after_parse({data, _, IsFin, _, State=#state{buffer=Buffer}})</code> - @todo Should call parse after this.
        stream_terminate(State0, StreamID, {internal_error, {Class, Exception},
            'Unhandled exception in cowboy_stream:data/4.'})
    end;
%% No corresponding stream. We must skip the body of the previous request
%% in order to process the next one.
- <code>update_flow(nofin, Data, State0=#state{flow=Flow0})</code> - This function is only called after parsing, therefore we
    %% are expecting to be in active mode already.
    State#state{flow=infinity};
- <code>parse_request(Buffer, State=#state{opts=Opts, in_streamid=InStreamID}, EmptyLines)</code> - We limit the length of the Request-line to MaxLength to avoid endlessly
%% reading from the socket and eventually crashing.
- <code>match_eol(&lt;&lt; $\n, _/bits &gt;&gt;, N)</code> - @todo * is only for server-wide OPTIONS request (RFC7230 5.3.4); tests
                &lt;&lt; "OPTIONS * ", Rest/bits &gt;&gt; -&gt;
                    parse_version(Rest, State, &lt;&lt;"OPTIONS"&gt;&gt;, undefined, &lt;&lt;"*"&gt;&gt;, &lt;&lt;&gt;&gt;);
                &lt;&lt;"CONNECT ", <em>/bits&gt;&gt; -&gt;
                    error_terminate(501, State, {connection_error, no_error,
                        'The CONNECT method is currently not implemented. (RFC7231 4.3.6)'});
                &lt;&lt;"TRACE ", </em>/bits&gt;&gt; -&gt;
                    error_terminate(501, State, {connection_error, no_error,
                        'The TRACE method is currently not implemented. (RFC7231 4.3.8)'});
                %% Accept direct HTTP/2 only at the beginning of the connection.
                &lt;&lt; "PRI * HTTP/2.0\r\n", _/bits &gt;&gt; when InStreamID =:= 1 -&gt;
                    case lists:member(http2, maps:get(protocols, Opts, [http2, http])) of
                        true -&gt;
                            http2_upgrade(State, Buffer);
                        false -&gt;
                            error_terminate(501, State, {connection_error, no_error,
                                'Prior knowledge upgrade to HTTP/2 is disabled by configuration.'})
                    end;
                _ -&gt;
                    parse_method(Buffer, State, &lt;&lt;&gt;&gt;,
                        maps:get(max_method_length, Opts, 32))
            end
    end.
- <code>parse_uri_authority(Rest, State=#state{opts=Opts}, Method)</code> - @todo We probably want to apply max_authority_length also
%% to the host header and to document this option. It might
%% also be useful for HTTP/2 requests.
- <code>parse_header(Rest, State=#state{in_state=PS}, Headers) when byte_size(Rest) &lt; 2 -&gt;
    {more, State#state{buffer=Rest, in_state=PS#ps_header{headers=Headers}}};
parse_header(&lt;&lt; $\r, $\n, Rest/bits &gt;&gt;, S, Headers)</code> - Headers.</p>
<p>%% We need two or more bytes in the buffer to continue.
- <code>match_colon(&lt;&lt; $:, _/bits &gt;&gt;, N)</code> - We don't have a colon but we might have an invalid header line,
            %% so check if we have an LF and abort with an error if we do.
            case match_eol(Buffer, 0) of
                nomatch -&gt;
                    {more, State#state{buffer=Buffer, in_state=PS#ps_header{headers=Headers}}};
                _ -&gt;
                    error_terminate(400, State#state{in_state=PS#ps_header{headers=Headers}},
                        {connection_error, protocol_error,
                            'A header line is missing a colon separator. (RFC7230 3.2.4)'})
            end;
        _ -&gt;
            parse_hd_name(Buffer, State, Headers, &lt;&lt;&gt;&gt;)
    end.
- <code>parse_hd_value(&lt;&lt; C, Rest/bits &gt;&gt;, S, H, N, SoFar)</code> - The cookie header does not use proper HTTP header lists.
        Value0 when Name =:= &lt;&lt;"cookie"&gt;&gt; -&gt; Headers0#{Name =&gt; &lt;&lt; Value0/binary, "; ", Value/binary &gt;&gt;};
        Value0 -&gt; Headers0#{Name =&gt; &lt;&lt; Value0/binary, ", ", Value/binary &gt;&gt;}
    end,
    parse_header(Rest, S, Headers);
- <code>request_parse_host(Buffer, State=#state{transport=Transport, in_state=PS}, Headers, RawHost)</code> - @todo Might want to not close the connection on this and next one.
            error_terminate(400, State#state{in_state=PS#ps_header{headers=Headers}},
                {stream_error, protocol_error,
                    'HTTP/1.1 requests must include a host header. (RFC7230 5.4)'});
        undefined -&gt;
            request(Buffer, State, Headers, &lt;&lt;&gt;&gt;, default_port(Transport:secure()));
        %% @todo When CONNECT requests come in we need to ignore the RawHost
        %% and instead use the Authority as the source of host.
        RawHost when Authority =:= undefined; Authority =:= RawHost -&gt;
            request_parse_host(Buffer, State, Headers, RawHost);
        %% RFC7230 does not explicitly ask us to reject requests
        %% that have a different authority component and host header.
        %% However it DOES ask clients to set them to the same value,
        %% so we enforce that.
        _ -&gt;
            error_terminate(400, State#state{in_state=PS#ps_header{headers=Headers}},
                {stream_error, protocol_error,
                    'The host header is different than the absolute-form authority component. (RFC7230 5.4)'})
    end.
- <code>request(Buffer, State0=#state{ref=Ref, transport=Transport, peer=Peer, sock=Sock, cert=Cert,
        opts=Opts, proxy_header=ProxyHeader, in_streamid=StreamID, in_state=
            PS=#ps_header{method=Method, path=Path, qs=Qs, version=Version}},
        Headers, Host, Port)</code> - End of request parsing.
- <code>is_http2_upgrade(#{&lt;&lt;"connection"&gt;&gt; := Conn, &lt;&lt;"upgrade"&gt;&gt; := Upgrade,
        &lt;&lt;"http2-settings"&gt;&gt; := HTTP2Settings}, 'HTTP/1.1', Opts)</code> - We are transparently taking care of transfer-encodings so
        %% the user code has no need to know about it.
        headers =&gt; maps:remove(&lt;&lt;"transfer-encoding"&gt;&gt;, Headers),
        has_body =&gt; HasBody,
        body_length =&gt; BodyLength
    },
    %% We add the PROXY header information if any.
    Req = case ProxyHeader of
        undefined -&gt; Req0;
        _ -&gt; Req0#{proxy_header =&gt; ProxyHeader}
    end,
    case is_http2_upgrade(Headers, Version, Opts) of
        false -&gt;
            State = case HasBody of
                true -&gt;
                    State0#state{in_state=#ps_body{
                        length = BodyLength,
                        transfer_decode_fun = TDecodeFun,
                        transfer_decode_state = TDecodeState
                    }};
                false -&gt;
                    State0#state{in_streamid=StreamID + 1, in_state=#ps_request_line{}}
            end,
            {request, Req, State#state{buffer=Buffer}};
        {true, HTTP2Settings} -&gt;
            %% We save the headers in case the upgrade will fail
            %% and we need to pass them to cowboy_stream:early_error.
            http2_upgrade(State0#state{in_state=PS#ps_header{headers=Headers}},
                Buffer, HTTP2Settings, Req)
    end.</p>
<p>%% HTTP/2 upgrade.
- <code>http2_upgrade(State=#state{parent=Parent, ref=Ref, socket=Socket, transport=Transport,
        proxy_header=ProxyHeader, peer=Peer, sock=Sock, cert=Cert},
        Buffer, HTTP2Settings, Req)</code> - Upgrade via an HTTP/1.1 request.
- <code>opts_for_upgrade(#state{opts=Opts, dynamic_buffer_size=false})</code> - @todo
            %% However if the client sent a body, we need to read the body in full
            %% and if we can't do that, return a 413 response. Some options are in order.
            %% Always half-closed stream coming from this side.
            try cow_http_hd:parse_http2_settings(HTTP2Settings) of
                Settings -&gt;
                    _ = cancel_timeout(State),
                    cowboy_http2:init(Parent, Ref, Socket, Transport, ProxyHeader,
                        opts_for_upgrade(State), Peer, Sock, Cert, Buffer, Settings, Req)
            catch <em>:</em> -&gt;
                error_terminate(400, State, {connection_error, protocol_error,
                    'The HTTP2-Settings header must contain a base64 SETTINGS payload. (RFC7540 3.2, RFC7540 3.2.1)'})
            end;
        true -&gt;
            error_terminate(400, State, {connection_error, protocol_error,
                'Clients that support HTTP/2 over TLS MUST use ALPN. (RFC7540 3.4)'})
    end.
- <code>parse_body(Buffer, State=#state{in_streamid=StreamID, in_state=
        PS=#ps_body{received=Received, transfer_decode_fun=TDecode,
            transfer_decode_state=TState0}})</code> - Request body parsing.
- <code>down(State=#state{opts=Opts, children=Children0}, Pid, Msg)</code> - @todo Proper trailers.
    try TDecode(Buffer, TState0) of
        more -&gt;
            {more, State#state{buffer=Buffer}};
        {more, Data, TState} -&gt;
            {data, StreamID, nofin, Data, State#state{buffer= &lt;&lt;&gt;&gt;,
                in_state=PS#ps_body{received=Received + byte_size(Data),
                    transfer_decode_state=TState}}};
        {more, Data, <em>Length, TState} when is_integer(_Length) -&gt;
            {data, StreamID, nofin, Data, State#state{buffer= &lt;&lt;&gt;&gt;,
                in_state=PS#ps_body{received=Received + byte_size(Data),
                    transfer_decode_state=TState}}};
        {more, Data, Rest, TState} -&gt;
            {data, StreamID, nofin, Data, State#state{buffer=Rest,
                in_state=PS#ps_body{received=Received + byte_size(Data),
                    transfer_decode_state=TState}}};
        {done, _HasTrailers, Rest} -&gt;
            {data, StreamID, fin, &lt;&lt;&gt;&gt;,
                State#state{buffer=Rest, in_streamid=StreamID + 1, in_state=#ps_request_line{}}};
        {done, Data, _HasTrailers, Rest} -&gt;
            {data, StreamID, fin, Data,
                State#state{buffer=Rest, in_streamid=StreamID + 1, in_state=#ps_request_line{}}}
    catch </em>:_ -&gt;
        Reason = {connection_error, protocol_error,
            'Failure to decode the content. (RFC7230 4)'},
        terminate(stream_terminate(State, StreamID, Reason), Reason)
    end.</p>
<p>%% Message handling.
- <code>info(State=#state{opts=Opts, streams=Streams0}, StreamID, Msg)</code> - The stream was terminated already.
        {ok, undefined, Children} -&gt;
            State#state{children=Children};
        %% The stream is still running.
        {ok, StreamID, Children} -&gt;
            info(State#state{children=Children}, StreamID, Msg);
        %% The process was unknown.
        error -&gt;
            cowboy:log(warning, "Received EXIT signal ~p for unknown process ~p.~n",
                [Msg, Pid], Opts),
            State
    end.
- <code>commands(State, StreamID, [{push, _, _, _, _, _, _, _}|Tail])</code> - HTTP/1.1 does not support push; ignore.
- <code>headers_to_list(Headers0=#{&lt;&lt;"set-cookie"&gt;&gt; := SetCookies})</code> - The set-cookie header is special; we can only send one cookie per header.
- <code>sendfile(State=#state{socket=Socket, transport=Transport, opts=Opts},
        {sendfile, Offset, Bytes, Path})</code> - We wrap the sendfile call into a try/catch because on OTP-20
%% and earlier a few different crashes could occur for sockets
%% that were closing or closed. For example a badarg in
%% erlang:port_get_data(#Port&lt;...&gt;) or a badmatch like
%% {{badmatch,{error,einval}},[{prim_file,sendfile,8,[]}...
%%
%% OTP-21 uses a NIF instead of a port so the implementation
%% and behavior has dramatically changed and it is unclear
%% whether it will be necessary in the future.
%%
%% This try/catch prevents some noisy logs to be written
%% when these errors occur.
- <code>flush(Parent)</code> - When sendfile is disabled we explicitly use the fallback.
        {ok, <em>} = maybe_socket_error(State,
            case maps:get(sendfile, Opts, true) of
                true -&gt; Transport:sendfile(Socket, Path, Offset, Bytes);
                false -&gt; ranch_transport:sendfile(Transport, Socket, Path, Offset, Bytes, [])
            end
        ),
        ok
    catch </em>:_ -&gt;
        terminate(State, {socket_error, sendfile_crash,
            'An error occurred when using the sendfile function.'})
    end.</p>
<p>%% Flush messages specific to cowboy_http before handing over the
%% connection to another protocol.
- <code>maybe_terminate(State, StreamID, _Tail)</code> - @todo Reason ok?
- <code>stream_next(State0=#state{opts=Opts, active=Active, out_streamid=OutStreamID, streams=Streams})</code> - Send a response or terminate chunks depending on the current output state.
    State1 = #state{streams=Streams1} = case OutState of
        wait when element(1, Reason) =:= internal_error -&gt;
            info(State0, StreamID, {response, 500, #{&lt;&lt;"content-length"&gt;&gt; =&gt; &lt;&lt;"0"&gt;&gt;}, &lt;&lt;&gt;&gt;});
        wait when element(1, Reason) =:= connection_error -&gt;
            info(State0, StreamID, {response, 400, #{&lt;&lt;"content-length"&gt;&gt; =&gt; &lt;&lt;"0"&gt;&gt;}, &lt;&lt;&gt;&gt;});
        wait -&gt;
            info(State0, StreamID, {response, 204, #{}, &lt;&lt;&gt;&gt;});
        chunked when Version =:= 'HTTP/1.1' -&gt;
            info(State0, StreamID, {data, fin, &lt;&lt;&gt;&gt;});
        streaming when SentSize &lt; ExpectedSize -&gt;
            terminate(State0, response_body_too_small);
        _ -&gt; %% done or Version =:= 'HTTP/1.0'
            State0
    end,
    %% Stop the stream, shutdown children and reset overriden options.
    {value, #stream{state=StreamState}, Streams}
        = lists:keytake(StreamID, #stream.id, Streams1),
    stream_call_terminate(StreamID, Reason, StreamState, State1),
    Children = cowboy_children:shutdown(Children0, StreamID),
    State = State1#state{overriden_opts=#{}, streams=Streams, children=Children},
    %% We want to drop the connection if the body was not read fully
    %% and we don't know its length or more remains to be read than
    %% configuration allows.
    MaxSkipBodyLength = maps:get(max_skip_body_length, Opts, 1000000),
    case InState of
        #ps_body{length=undefined}
                when InStreamID =:= OutStreamID -&gt;
            terminate(State, skip_body_unknown_length);
        #ps_body{length=Len, received=Received}
                when InStreamID =:= OutStreamID, Received + MaxSkipBodyLength &lt; Len -&gt;
            terminate(State, skip_body_too_large);
        #ps_body{} when InStreamID =:= OutStreamID -&gt;
            stream_next(State#state{flow=infinity});
        _ -&gt;
            stream_next(State)
    end.
- <code>stream_call_terminate(StreamID, Reason, StreamState, #state{opts=Opts})</code> - Enable active mode again if it was disabled.
    State1 = case Active of
        true -&gt; State0;
        false -&gt; active(State0)
    end,
    NextOutStreamID = OutStreamID + 1,
    case lists:keyfind(NextOutStreamID, #stream.id, Streams) of
        false -&gt;
            State = State1#state{out_streamid=NextOutStreamID, out_state=wait},
            %% There are no streams remaining. We therefore can
            %% and want to switch back to the request_timeout.
            set_timeout(State, request_timeout);
        #stream{queue=Commands} -&gt;
            %% @todo Remove queue from the stream.
            %% We set the flow to the initial flow size even though
            %% we might have sent some data through already due to pipelining.
            Flow = maps:get(initial_stream_flow_size, Opts, 65535),
            commands(State1#state{flow=Flow, out_streamid=NextOutStreamID, out_state=wait},
                NextOutStreamID, Commands)
    end.
- <code>connection(State, Headers, _, 'HTTP/1.0')</code> - @todo Here we need to set keep-alive only if it wasn't set before.
        false -&gt; {State, Headers}
    end;
- <code>stream_te(_, #stream{te=undefined})</code> - No TE header was sent.
- <code>error_terminate(StatusCode, State=#state{ref=Ref, peer=Peer, in_state=StreamState}, Reason)</code> - If we can't parse the TE header, assume we can't send trailers.
        no_trailers
    end.</p>
<p>%% This function is only called when an error occurs on a new stream.
-spec error_terminate(cowboy:http_status(), #state{}, <em>) -&gt; no_return().
- <code>initiate_closing(State=#state{streams=[]}, Reason)</code> - @todo We shouldn't send the body when the method is HEAD.
                    %% @todo Technically we allow the sendfile tuple.
                    RespBody
                ])
            )
    catch Class:Exception:Stacktrace -&gt;
        cowboy:log(cowboy_stream:make_error_log(early_error,
            [StreamID, Reason, PartialReq, Resp, Opts],
            Class, Exception, Stacktrace), Opts),
        %% We still need to send an error response, so send what we initially
        %% wanted to send. It's better than nothing.
        ok = maybe_socket_error(State,
            Transport:send(Socket, cow_http:response(StatusCode0,
                'HTTP/1.1', maps:to_list(RespHeaders1)))
        )
    end.
- <code>maybe_socket_error(State, {error, closed})</code> - Function replicated in cowboy_http2.
- <code>terminate_linger_loop(State=#state{socket=Socket}, TimerRef, Messages)</code> - We may already be in active mode when we do this
    %% but it's OK because we are shutting down anyway.
    %%
    %% We specially handle the socket error to terminate
    %% when an error occurs.
    case setopts_active(State) of
        ok -&gt;
            terminate_linger_loop(State, TimerRef, Messages);
        {error, </em>} -&gt;
            ok
    end.
- <code>system_continue(_, _, State)</code> - System callbacks.</p>
<p>-spec system_continue(<em>, </em>, #state{}) -&gt; ok.</p>
<p><strong>Dependencies</strong>: cowboy_http2, cowboy_tracer_h, cowboy_req, cowboy_middleware, cowboy_stream, cowboy_children, cowboy, cowboy_metrics_h</p>
<hr />
<h3 id="cowboy_http2">cowboy_http2</h3>
<p><strong>File</strong>: <code>/Users/ddleon/.erlviz/cache/ninenines_cowboy/src/cowboy_http2.erl</code></p>
<p><strong>Description</strong>:
Copyright (c) Loïc Hoguin <a href="&#109;&#97;&#105;&#108;&#116;&#111;&#58;&#101;&#115;&#115;&#101;&#110;&#64;&#110;&#105;&#110;&#101;&#110;&#105;&#110;&#101;&#115;&#46;&#101;&#117;">&#101;&#115;&#115;&#101;&#110;&#64;&#110;&#105;&#110;&#101;&#110;&#105;&#110;&#101;&#115;&#46;&#101;&#117;</a>
%% Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted, provided that the above
copyright notice and this permission notice appear in all copies.
%% THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF</p>
<p><strong>Exported Functions</strong>: init/6, init/10, init/12, loop/2, system_continue/3, system_terminate/4, system_code_change/4</p>
<p><strong>Functions</strong>:</p>
<ul>
<li><code>init(Parent, Ref, Socket, Transport, ProxyHeader, Opts, Peer, Sock, Cert, Buffer,
        _Settings, Req=#{method := Method})</code> - @todo Add an argument for the request body.
-spec init(pid(), ranch:ref(), inet:socket(), module(),
    ranch_proxy_header:proxy_info() | undefined, cowboy:opts(),
    {inet:ip_address(), inet:port_number()}, {inet:ip_address(), inet:port_number()},
    binary() | undefined, binary(), map() | undefined, cowboy_req:req()) -&gt; no_return().</li>
<li><code>init_rate_limiting(State0)</code> - Send the preface before doing all the init in case we get a socket error.
    ok = maybe_socket_error(undefined, Transport:send(Socket, Preface)),
    State = set_idle_timeout(init_rate_limiting(#state{parent=Parent, ref=Ref, socket=Socket,
        transport=Transport, proxy_header=ProxyHeader,
        opts=Opts, peer=Peer, sock=Sock, cert=Cert,
        dynamic_buffer_size=DynamicBuffer,
        dynamic_buffer_moving_average=maps:get(dynamic_buffer_initial_average, Opts, 0),
        http2_status=sequence, http2_machine=HTTP2Machine}), 0),
    safe_setopts_active(State),
    case Buffer of
        &lt;&lt;&gt;&gt; -&gt; before_loop(State, Buffer);
        _ -&gt; parse(State, Buffer)
    end.</li>
<li><code>setopts_active(#state{socket=Socket, transport=Transport, opts=Opts})</code> - We assume that the upgrade will be applied. A stream handler
    %% must not prevent the normal operations of the server.
    State2 = info(State1, 1, {switch_protocol, #{
        &lt;&lt;"connection"&gt;&gt; =&gt; &lt;&lt;"Upgrade"&gt;&gt;,
        &lt;&lt;"upgrade"&gt;&gt; =&gt; &lt;&lt;"h2c"&gt;&gt;
    }, ?MODULE, undefined}), %% @todo undefined or #{}?
    State = set_idle_timeout(init_rate_limiting(State2#state{http2_status=sequence}), 0),
    %% In the case of HTTP/1.1 Upgrade we cannot send the Preface
    %% until we send the 101 response.
    ok = maybe_socket_error(State, Transport:send(Socket, Preface)),
    safe_setopts_active(State),
    case Buffer of
        &lt;&lt;&gt;&gt; -&gt; before_loop(State, Buffer);
        _ -&gt; parse(State, Buffer)
    end.</li>
</ul>
<p>-include("cowboy_dynamic_buffer.hrl").</p>
<p>%% Because HTTP/2 has flow control and Cowboy has other rate limiting
%% mechanisms implemented, a very large active_n value should be fine,
%% as long as the stream handlers do their work in a timely manner.
%% However large active_n values reduce the impact of dynamic_buffer.
- <code>tick_idle_timeout(State=#state{idle_timeout_num=?IDLE_TIMEOUT_TICKS}, _)</code> - Socket messages.
        {OK, Socket, Data} when OK =:= element(1, Messages) -&gt;
            State1 = maybe_resize_buffer(State, Data),
            parse(State1#state{idle_timeout_num=0}, &lt;&lt; Buffer/binary, Data/binary &gt;&gt;);
        {Closed, Socket} when Closed =:= element(2, Messages) -&gt;
            Reason = case State#state.http2_status of
                closing -&gt; {stop, closed, 'The client is going away.'};
                _ -&gt; {socket_error, closed, 'The socket has been closed.'}
            end,
            terminate(State, Reason);
        {Error, Socket, Reason} when Error =:= element(3, Messages) -&gt;
            terminate(State, {socket_error, Reason, 'An error has occurred on the socket.'});
        {Passive, Socket} when Passive =:= element(4, Messages);
                %% Hardcoded for compatibility with Ranch 1.x.
                Passive =:= tcp_passive; Passive =:= ssl_passive -&gt;
            safe_setopts_active(State),
            before_loop(State, Buffer);
        %% System messages.
        {'EXIT', Parent, shutdown} -&gt;
            Reason = {stop, {exit, shutdown}, 'Parent process requested shutdown.'},
            before_loop(initiate_closing(State, Reason), Buffer);
        {'EXIT', Parent, Reason} -&gt;
            terminate(State, {stop, {exit, Reason}, 'Parent process terminated.'});
        {system, From, Request} -&gt;
            sys:handle_system_msg(Request, From, Parent, ?MODULE, [], {State, Buffer});
        %% Timeouts.
        {timeout, TimerRef, idle_timeout} -&gt;
            tick_idle_timeout(State, Buffer);
        {timeout, Ref, {shutdown, Pid}} -&gt;
            cowboy_children:shutdown_timeout(Children, Ref, Pid),
            before_loop(State, Buffer);
        {timeout, TRef, {cow_http2_machine, Name}} -&gt;
            before_loop(timeout(State, Name, TRef), Buffer);
        {timeout, TimerRef, {goaway_initial_timeout, Reason}} -&gt;
            before_loop(closing(State, Reason), Buffer);
        {timeout, TimerRef, {goaway_complete_timeout, Reason}} -&gt;
            terminate(State, {stop, stop_reason(Reason),
                'Graceful shutdown timed out.'});
        %% Messages pertaining to a stream.
        {{Pid, StreamID}, Msg} when Pid =:= self() -&gt;
            before_loop(info(State, StreamID, Msg), Buffer);
        %% Exit signal from children.
        Msg = {'EXIT', Pid, _} -&gt;
            before_loop(down(State, Pid, Msg), Buffer);
        %% Calls from supervisor module.
        {'$gen_call', From, Call} -&gt;
            cowboy_children:handle_supervisor_call(Call, From, Children, ?MODULE),
            before_loop(State, Buffer);
        Msg -&gt;
            cowboy:log(warning, "Received stray message ~p.", [Msg], Opts),
            before_loop(State, Buffer)
    after InactivityTimeout -&gt;
        terminate(State, {internal_error, timeout, 'No message or data received before timeout.'})
    end.
- <code>parse(State=#state{http2_status=sequence}, Data)</code> - HTTP/2 protocol parsing.
- <code>frame_rate(State0=#state{frame_rate_num=Num0, frame_rate_time=Time}, Frame)</code> - Terminate the connection if we are closing and all streams have completed.
        more when Status =:= closing, Streams =:= #{} -&gt;
            terminate(State, {stop, normal, 'The connection is going away.'});
        more -&gt;
            before_loop(State, Data)
    end.</p>
<p>%% Frame rate flood protection.
- <code>frame(State=#state{http2_machine=HTTP2Machine0}, Frame)</code> - When the option has a period of infinity we cannot reach this clause.
                    {ok, init_frame_rate_limiting(State0, CurrentTime)}
            end;
        Num -&gt;
            {ok, State0#state{frame_rate_num=Num}}
    end,
    case {Result, Frame} of
        {ok, ignore} -&gt; ignored_frame(State);
        {ok, <em>} -&gt; frame(State, Frame);
        {error, </em>} -&gt; terminate(State, {connection_error, enhance_your_calm,
            'Frame rate larger than configuration allows. Flood? (CVE-2019-9512, CVE-2019-9515, CVE-2019-9518)'})
    end.</p>
<p>%% Frames received.</p>
<p>%% We do nothing when receiving a lingering DATA frame.
%% We already removed the stream flow from the connection
%% flow and are therefore already accounting for the window
%% being reduced by these frames.
- <code>maybe_ack(State=#state{socket=Socket, transport=Transport}, Frame)</code> - We do not reset the idle timeout on send here because we are
%% sending data as a consequence of receiving data, which means
%% we already resetted the idle timeout.
- <code>headers_frame(State=#state{opts=Opts, streams=Streams}, StreamID, Req)</code> - The cookie header does not use proper HTTP header lists.
        #{Name := Value0} when Name =:= &lt;&lt;"cookie"&gt;&gt; -&gt;
            Acc0#{Name =&gt; &lt;&lt; Value0/binary, "; ", Value/binary &gt;&gt;};
        #{Name := Value0} -&gt;
            Acc0#{Name =&gt; &lt;&lt; Value0/binary, ", ", Value/binary &gt;&gt;};
        _ -&gt;
            Acc0#{Name =&gt; Value}
    end,
    headers_to_map(Tail, Acc).
- <code>ensure_port(&lt;&lt;"http"&gt;&gt;, undefined)</code> - We add the PROXY header information if any.
                    Req1 = case ProxyHeader of
                        undefined -&gt; Req0;
                        _ -&gt; Req0#{proxy_header =&gt; ProxyHeader}
                    end,
                    %% We add the protocol information for extended CONNECTs.
                    Req = case PseudoHeaders of
                        #{protocol := Protocol} -&gt; Req1#{protocol =&gt; Protocol};
                        _ -&gt; Req1
                    end,
                    headers_frame(State, StreamID, Req)
            catch <em>:</em> -&gt;
                reset_stream(State, StreamID, {stream_error, protocol_error,
                    'The :path pseudo-header is invalid. (RFC7540 8.1.2.3)'})
            end
    catch <em>:</em> -&gt;
        reset_stream(State, StreamID, {stream_error, protocol_error,
            'The :authority pseudo-header is invalid. (RFC7540 8.1.2.3)'})
    end.
- <code>headers_to_map([], Acc)</code> - This function is necessary to properly handle duplicate headers
%% and the special-case cookie header.
- <code>rst_stream_frame(State=#state{streams=Streams0, children=Children0}, StreamID, Reason)</code> - We automatically terminate the stream but it is not an error
    %% per se (at least not in the first implementation).
    Reason = {stream_error, no_error, HumanReadable},
    %% The partial Req is minimal for now. We only have one case
    %% where it can be called (when a method is completely disabled).
    %% @todo Fill in the other elements.
    PartialReq = #{
        ref =&gt; Ref,
        peer =&gt; Peer,
        method =&gt; Method,
        headers =&gt; headers_to_map(Headers, #{})
    },
    Resp = {response, StatusCode0, RespHeaders0=#{&lt;&lt;"content-length"&gt;&gt; =&gt; &lt;&lt;"0"&gt;&gt;}, &lt;&lt;&gt;&gt;},
    try cowboy_stream:early_error(StreamID, Reason, PartialReq, Resp, Opts) of
        {response, StatusCode, RespHeaders, RespBody} -&gt;
            send_response(State0, StreamID, StatusCode, RespHeaders, RespBody)
    catch Class:Exception:Stacktrace -&gt;
        cowboy:log(cowboy_stream:make_error_log(early_error,
            [StreamID, Reason, PartialReq, Resp, Opts],
            Class, Exception, Stacktrace), Opts),
        %% We still need to send an error response, so send what we initially
        %% wanted to send. It's better than nothing.
        send_headers(State0, StreamID, fin, StatusCode0, RespHeaders0)
    end.
- <code>ignored_frame(State=#state{http2_machine=HTTP2Machine0})</code> - When the option has a period of infinity we cannot reach this clause.
                    init_cancel_rate_limiting(State0, CurrentTime)
            end;
        Num -&gt;
            State0#state{cancel_rate_num=Num}
    end.
- <code>timeout(State=#state{http2_machine=HTTP2Machine0}, Name, TRef)</code> - HTTP/2 timeouts.
- <code>down(State0=#state{opts=Opts, children=Children0}, Pid, Msg)</code> - Erlang messages.
- <code>info(State=#state{opts=Opts, http2_machine=HTTP2Machine, streams=Streams}, StreamID, Msg)</code> - The stream was terminated already.
        {ok, undefined, Children} -&gt;
            State0#state{children=Children};
        %% The stream is still running.
        {ok, StreamID, Children} -&gt;
            info(State0#state{children=Children}, StreamID, Msg);
        %% The process was unknown.
        error -&gt;
            cowboy:log(warning, "Received EXIT signal ~p for unknown process ~p.~n",
                [Msg, Pid], Opts),
            State0
    end,
    if
        State#state.http2_status =:= closing, State#state.streams =:= #{} -&gt;
            terminate(State, {stop, normal, 'The connection is going away.'});
        true -&gt;
            State
    end.
- <code>commands(State=#state{opts=Opts}, StreamID, [Log={log, _, _, _}|Tail])</code> - @todo Do we want to run the commands after a stop?
    %% @todo Do we even allow commands after?
    stop_stream(State, StreamID);
%% Log event.
- <code>update_window(State0=#state{socket=Socket, transport=Transport,
        http2_machine=HTTP2Machine0, flow=Flow, streams=Streams}, StreamID)</code> - Tentatively update the window after the flow was updated.
- <code>send_response(State0=#state{http2_machine=HTTP2Machine0}, StreamID, StatusCode, Headers, Body)</code> - Don't update the stream's window if it stopped.
            {&lt;&lt;&gt;&gt;, HTTP2Machine2}
    end,
    State = State0#state{http2_machine=HTTP2Machine},
    case {Data1, Data2} of
        {&lt;&lt;&gt;&gt;, &lt;&lt;&gt;&gt;} -&gt;
            State;
        _ -&gt;
            ok = maybe_socket_error(State, Transport:send(Socket, [Data1, Data2])),
            maybe_reset_idle_timeout(State)
    end.</p>
<p>%% Send the response, trailers or data.
- <code>send_headers(State0=#state{socket=Socket, transport=Transport,
        http2_machine=HTTP2Machine0}, StreamID, IsFin0, StatusCode, Headers)</code> - @todo Add a test for HEAD to make sure we don't send the body when
            %% returning {response...} from a stream handler (or {headers...} then {data...}).
            {ok, <em>IsFin, HeaderBlock, HTTP2Machine}
                = cow_http2_machine:prepare_headers(StreamID, HTTP2Machine0, nofin,
                    #{status =&gt; cow_http:status_to_integer(StatusCode)},
                    headers_to_list(Headers)),
            {</em>, State} = maybe_send_data(State0#state{http2_machine=HTTP2Machine},
                StreamID, fin, Body, [cow_http2:headers(StreamID, nofin, HeaderBlock)]),
            State
    end.
- <code>headers_to_list(Headers0=#{&lt;&lt;"set-cookie"&gt;&gt; := SetCookies})</code> - The set-cookie header is special; we can only send one cookie per header.
- <code>send_data(State0=#state{socket=Socket, transport=Transport, opts=Opts}, SendData, Prefix)</code> - If we have prefix data (like a HEADERS frame) we need to send it
            %% even if we do not send any DATA frames.
            WasDataSent = case Prefix of
                [] -&gt;
                    no_data_sent;
                _ -&gt;
                    ok = maybe_socket_error(State1, Transport:send(Socket, Prefix)),
                    data_sent
            end,
            State = maybe_send_data_alarm(State1, HTTP2Machine0, StreamID),
            {WasDataSent, State};
        {send, SendData, HTTP2Machine} -&gt;
            State = #state{http2_status=Status, streams=Streams}
                = send_data(State0#state{http2_machine=HTTP2Machine}, SendData, Prefix),
            %% Terminate the connection if we are closing and all streams have completed.
            if
                Status =:= closing, Streams =:= #{} -&gt;
                    terminate(State, {stop, normal, 'The connection is going away.'});
                true -&gt;
                    {data_sent, maybe_send_data_alarm(State, HTTP2Machine0, StreamID)}
            end
    end.
- <code>send_data_terminate(State, [])</code> - When sendfile is disabled we explicitly use the fallback.
            {ok, _} = maybe_socket_error(State,
                case maps:get(sendfile, Opts, true) of
                    true -&gt; Transport:sendfile(Socket, Path, Offset, Bytes);
                    false -&gt; ranch_transport:sendfile(Transport, Socket, Path, Offset, Bytes, [])
                end
            ),
            ok;
        _ -&gt;
            ok = maybe_socket_error(State, Transport:send(Socket, Data))
    end || Data &lt;- Acc],
    send_data_terminate(State, SendData).
- <code>prepare_data_frame(State=#state{http2_machine=HTTP2Machine0},
        StreamID, nofin, {trailers, Trailers})</code> - The stream is terminated in cow_http2_machine:prepare_trailers.
- <code>maybe_send_data_alarm(State=#state{opts=Opts, http2_machine=HTTP2Machine}, HTTP2Machine0, StreamID)</code> - After we have sent or queued data we may need to set or clear an alarm.
%% We do this by comparing the HTTP2Machine buffer state before/after for
%% the relevant streams.
- <code>connection_alarm(State0=#state{streams=Streams}, Name, Value)</code> - When the stream ends up closed after it finished sending data,
    %% we do not want to trigger an alarm. We act as if the buffer
    %% size did not change.
    StreamBufferSizeAfter = case cow_http2_machine:get_stream_local_buffer_size(StreamID, HTTP2Machine) of
        {ok, BSA} -&gt; BSA;
        {error, closed} -&gt; StreamBufferSizeBefore
    end,
    MaxConnBufferSize = maps:get(max_connection_buffer_size, Opts, 16000000),
    MaxStreamBufferSize = maps:get(max_stream_buffer_size, Opts, 8000000),
    %% I do not want to document these internal events yet. I am not yet
    %% convinced it should be {alarm, Name, on|off} and not {internal_event, E}
    %% or something else entirely. Though alarms are probably right.
    if
        ConnBufferSizeBefore &gt;= MaxConnBufferSize, ConnBufferSizeAfter &lt; MaxConnBufferSize -&gt;
            connection_alarm(State, connection_buffer_full, off);
        ConnBufferSizeBefore &lt; MaxConnBufferSize, ConnBufferSizeAfter &gt;= MaxConnBufferSize -&gt;
            connection_alarm(State, connection_buffer_full, on);
        StreamBufferSizeBefore &gt;= MaxStreamBufferSize, StreamBufferSizeAfter &lt; MaxStreamBufferSize -&gt;
            stream_alarm(State, StreamID, stream_buffer_full, off);
        StreamBufferSizeBefore &lt; MaxStreamBufferSize, StreamBufferSizeAfter &gt;= MaxStreamBufferSize -&gt;
            stream_alarm(State, StreamID, stream_buffer_full, on);
        true -&gt;
            State
    end.
- <code>goaway(State0=#state{socket=Socket, transport=Transport, http2_machine=HTTP2Machine0,
        http2_status=Status, streams=Streams0}, {goaway, LastStreamID, Reason, _})
        when Status =:= connected; Status =:= closing_initiated; Status =:= closing -&gt;
    Streams = goaway_streams(State0, maps:to_list(Streams0), LastStreamID,
        {stop, {goaway, Reason}, 'The connection is going away.'}, []),
    State1 = State0#state{streams=maps:from_list(Streams)},
    if
        Status =:= connected; Status =:= closing_initiated -&gt;
            {OurLastStreamID, HTTP2Machine} =
                cow_http2_machine:set_last_streamid(HTTP2Machine0),
            State = State1#state{http2_status=closing, http2_machine=HTTP2Machine},
            ok = maybe_socket_error(State, Transport:send(Socket,
                cow_http2:goaway(OurLastStreamID, no_error, &lt;&lt;&gt;&gt;))),
            State;
        true -&gt;
            State1
    end;
%% We terminate the connection immediately if it hasn't fully been initialized.
goaway(State, {goaway, _, Reason, _})</code> - Terminate a stream or the connection.</p>
<p>%% We may have to cancel streams even if we receive multiple
%% GOAWAY frames as the LastStreamID value may be lower than
%% the one previously received.
%%
%% We do not reset the idle timeout on send here. We already
%% disabled it if we initiated shutdown; and we already reset
%% it if the client sent a GOAWAY frame.
- <code>goaway_streams(_, [], _, _, Acc)</code> - Cancel client-initiated streams that are above LastStreamID.
- <code>initiate_closing(State, Reason)</code> - This happens if sys:terminate/2,3 is called twice or if the supervisor
    %% tells us to shutdown after sys:terminate/2,3 is called or vice versa.
    State;
- <code>closing(State=#state{http2_status=closing, opts=Opts}, Reason)</code> - Stop accepting new streams.
    {LastStreamID, HTTP2Machine} =
        cow_http2_machine:set_last_streamid(HTTP2Machine0),
    State = State0#state{http2_status=closing, http2_machine=HTTP2Machine},
    ok = maybe_socket_error(State, Transport:send(Socket,
        cow_http2:goaway(LastStreamID, no_error, &lt;&lt;&gt;&gt;))),
    closing(State, Reason);
- <code>stop_reason({stop, Reason, _})</code> - If client sent GOAWAY, we may already be in 'closing' but without the
    %% goaway complete timeout set.
    Timeout = maps:get(goaway_complete_timeout, Opts, 3000),
    Message = {goaway_complete_timeout, Reason},
    set_timeout(State, Timeout, Message).
- <code>maybe_socket_error(State, {error, closed})</code> - Function copied from cowboy_http.
- <code>terminate(_State, Reason)</code> - @todo We might want to optionally send the Reason value
    %% as debug data in the GOAWAY frame here. Perhaps more.
    if
        Status =:= connected; Status =:= closing_initiated -&gt;
            %% We are terminating so it's OK if we can't send the GOAWAY anymore.
            _ = Transport:send(Socket, cow_http2:goaway(
                cow_http2_machine:get_last_streamid(HTTP2Machine),
                terminate_reason(Reason), &lt;&lt;&gt;&gt;));
        %% We already sent the GOAWAY frame.
        Status =:= closing -&gt;
            ok
    end,
    terminate_all_streams(State, maps:to_list(Streams), Reason),
    cowboy_children:terminate(Children),
    %% @todo Don't linger on connection errors.
    terminate_linger(State),
    exit({shutdown, Reason});
%% We are not fully connected so we can just terminate the connection.
- <code>terminate_linger(State=#state{socket=Socket, transport=Transport, opts=Opts})</code> - This code is copied from cowboy_http.
- <code>terminate_linger_loop(State=#state{socket=Socket}, TimerRef, Messages)</code> - We may already be in active mode when we do this
    %% but it's OK because we are shutting down anyway.
    %%
    %% We specially handle the socket error to terminate
    %% when an error occurs.
    case setopts_active(State) of
        ok -&gt;
            terminate_linger_loop(State, TimerRef, Messages);
        {error, <em>} -&gt;
            ok
    end.
- <code>reset_stream(State0=#state{socket=Socket, transport=Transport,
        http2_machine=HTTP2Machine0}, StreamID, Error)</code> - @todo Don't send an RST_STREAM if one was already sent.
%%
%% When resetting the stream we are technically sending data
%% on the socket. However due to implementation complexities
%% we do not attempt to reset the idle timeout on send.
- <code>stop_stream(State=#state{http2_machine=HTTP2Machine}, StreamID)</code> - When the option has a period of infinity we cannot reach this clause.
                    {ok, init_reset_rate_limiting(State0, CurrentTime)}
            end;
        Num -&gt;
            {ok, State0#state{reset_rate_num=Num}}
    end.
- <code>stopping(State=#state{streams=Streams}, StreamID)</code> - When the stream terminates normally (without sending RST_STREAM)
        %% and no response was sent, we need to send a proper response back to the client.
        %% We delay the termination of the stream until the response is fully sent.
        {ok, idle, </em>} -&gt;
            info(stopping(State, StreamID), StreamID, {response, 204, #{}, &lt;&lt;&gt;&gt;});
        %% When a response was sent but not terminated, we need to close the stream.
        %% We delay the termination of the stream until the response is fully sent.
        {ok, nofin, fin} -&gt;
            stopping(State, StreamID);
        %% We only send a final DATA frame if there isn't one queued yet.
        {ok, nofin, _} -&gt;
            info(stopping(State, StreamID), StreamID, {data, fin, &lt;&lt;&gt;&gt;});
        %% When a response was sent fully we can terminate the stream,
        %% regardless of the stream being in half-closed or closed state.
        _ -&gt;
            terminate_stream(State, StreamID)
    end.
- <code>maybe_terminate_stream(State=#state{streams=Streams}, StreamID, fin)</code> - If we finished sending data and the stream is stopping, terminate it.
- <code>terminate_stream(State=#state{flow=Flow, streams=Streams0, children=Children0}, StreamID, Reason)</code> - We remove the stream flow from the connection flow. Any further
%% data received for this stream is therefore fully contained within
%% the extra window we allocated for this stream.
- <code>system_continue(_, _, {State, Buffer})</code> - System callbacks.</p>
<p>-spec system_continue(<em>, </em>, {#state{}, binary()}) -&gt; no_return().</p>
<p><strong>Dependencies</strong>: cowboy_tracer_h, cowboy_req, cowboy_middleware, cowboy_stream, cowboy_children, cowboy, cowboy_metrics_h</p>
<hr />
<h3 id="cowboy_http3">cowboy_http3</h3>
<p><strong>File</strong>: <code>/Users/ddleon/.erlviz/cache/ninenines_cowboy/src/cowboy_http3.erl</code></p>
<p><strong>Description</strong>:
Copyright (c) Loïc Hoguin <a href="&#109;&#97;&#105;&#108;&#116;&#111;&#58;&#101;&#115;&#115;&#101;&#110;&#64;&#110;&#105;&#110;&#101;&#110;&#105;&#110;&#101;&#115;&#46;&#101;&#117;">&#101;&#115;&#115;&#101;&#110;&#64;&#110;&#105;&#110;&#101;&#110;&#105;&#110;&#101;&#115;&#46;&#101;&#117;</a>
%% Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted, provided that the above
copyright notice and this permission notice appear in all copies.
%% THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF</p>
<p><strong>Exported Functions</strong>: init/4, send/2</p>
<p><strong>Functions</strong>:</p>
<ul>
<li><code>init(Parent, Ref, Conn, Opts)</code> - Copyright (c) Loïc Hoguin <a href="&#109;&#97;&#105;&#108;&#116;&#111;&#58;&#101;&#115;&#115;&#101;&#110;&#64;&#110;&#105;&#110;&#101;&#110;&#105;&#110;&#101;&#115;&#46;&#101;&#117;">&#101;&#115;&#115;&#101;&#110;&#64;&#110;&#105;&#110;&#101;&#110;&#105;&#110;&#101;&#115;&#46;&#101;&#117;</a>
%%
%% Permission to use, copy, modify, and/or distribute this software for any
%% purpose with or without fee is hereby granted, provided that the above
%% copyright notice and this permission notice appear in all copies.
%%
%% THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
%% WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
%% MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
%% ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
%% WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
%% ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
%% OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.</li>
</ul>
<p>%% A key difference between cowboy_http2 and cowboy_http3
%% is that HTTP/3 streams are QUIC streams and therefore
%% much of the connection state is handled outside of
%% Cowboy.</p>
<p>-module(cowboy_http3).</p>
<p>-export([init/4]).</p>
<p>%% Temporary callback to do sendfile over QUIC.
-export([send/2]).</p>
<p>%% @todo Graceful shutdown? Linger? Timeouts? Frame rates? PROXY header?
-type opts() :: #{
    compress_buffering =&gt; boolean(),
    compress_threshold =&gt; non_neg_integer(),
    connection_type =&gt; worker | supervisor,
    enable_connect_protocol =&gt; boolean(),
    env =&gt; cowboy_middleware:env(),
    logger =&gt; module(),
    max_decode_blocked_streams =&gt; 0..16#3fffffffffffffff,
    max_decode_table_size =&gt; 0..16#3fffffffffffffff,
    max_encode_blocked_streams =&gt; 0..16#3fffffffffffffff,
    max_encode_table_size =&gt; 0..16#3fffffffffffffff,
    max_ignored_frame_size_received =&gt; non_neg_integer() | infinity,
    metrics_callback =&gt; cowboy_metrics_h:metrics_callback(),
    metrics_req_filter =&gt; fun((cowboy_req:req()) -&gt; map()),
    metrics_resp_headers_filter =&gt; fun((cowboy:http_headers()) -&gt; cowboy:http_headers()),
    middlewares =&gt; [module()],
    shutdown_timeout =&gt; timeout(),
    stream_handlers =&gt; [module()],
    tracer_callback =&gt; cowboy_tracer_h:tracer_callback(),
    tracer_flags =&gt; [atom()],
    tracer_match_specs =&gt; cowboy_tracer_h:tracer_match_specs(),
    %% Open ended because configured stream handlers might add options.
    _ =&gt; _
}.
-export_type([opts/0]).</p>
<p>%% HTTP/3 or WebTransport stream.
%%
%% WebTransport sessions involve one bidirectional CONNECT stream
%% that must stay open (and can be used for signaling using the
%% Capsule Protocol) and an application-defined number of
%% unidirectional and bidirectional streams, as well as datagrams.
%%
%% WebTransport sessions run in the CONNECT request process and
%% all events related to the session is sent there as a message.
%% The pid of the process is kept in the state.
-record(stream, {
    id :: cow_http3:stream_id(),</p>
<div class="codehilite"><pre><span></span><code><span class="c">%% Whether the stream is currently in a special state.</span>
<span class="n">status</span><span class="w"> </span><span class="s">::</span><span class="w"> </span><span class="s">header</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="p">{</span><span class="n">unidi</span><span class="p">,</span><span class="w"> </span><span class="n">control</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">encoder</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">decoder</span><span class="p">}</span>
<span class="w">    </span><span class="o">|</span><span class="w"> </span><span class="n">normal</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="p">{</span><span class="n">data</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">ignore</span><span class="p">,</span><span class="w"> </span><span class="n">non_neg_integer</span><span class="p">()}</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">stopping</span>
<span class="w">    </span><span class="o">|</span><span class="w"> </span><span class="p">{</span><span class="n">webtransport_session</span><span class="p">,</span><span class="w"> </span><span class="n">normal</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="p">{</span><span class="n">ignore</span><span class="p">,</span><span class="w"> </span><span class="n">non_neg_integer</span><span class="p">()}}</span>
<span class="w">    </span><span class="o">|</span><span class="w"> </span><span class="p">{</span><span class="n">webtransport_stream</span><span class="p">,</span><span class="w"> </span><span class="n">cow_http3</span><span class="p">:</span><span class="n">stream_id</span><span class="p">()},</span>

<span class="c">%% Stream buffer.</span>
<span class="n">buffer</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="o">&lt;&lt;&gt;&gt;</span><span class="w"> </span><span class="p">::</span><span class="w"> </span><span class="nb">binary</span><span class="p">(),</span>

<span class="c">%% Stream state.</span>
<span class="n">state</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="n">undefined</span><span class="w"> </span><span class="p">::</span><span class="w"> </span><span class="n">undefined</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="p">{</span><span class="n">module</span><span class="p">(),</span><span class="w"> </span><span class="nb">any</span><span class="p">()}</span>
</code></pre></div>

<p>}).</p>
<p>-record(state, {
    parent :: pid(),
    ref :: ranch:ref(),
    conn :: cowboy_quicer:quicer_connection_handle(),
    opts = #{} :: opts(),</p>
<div class="codehilite"><pre><span></span><code><span class="c">%% Remote address and port for the connection.</span>
<span class="n">peer</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="n">undefined</span><span class="w"> </span><span class="p">::</span><span class="w"> </span><span class="p">{</span><span class="n">inet</span><span class="p">:</span><span class="n">ip_address</span><span class="p">(),</span><span class="w"> </span><span class="n">inet</span><span class="p">:</span><span class="n">port_number</span><span class="p">()},</span>

<span class="c">%% Local address and port for the connection.</span>
<span class="n">sock</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="n">undefined</span><span class="w"> </span><span class="p">::</span><span class="w"> </span><span class="p">{</span><span class="n">inet</span><span class="p">:</span><span class="n">ip_address</span><span class="p">(),</span><span class="w"> </span><span class="n">inet</span><span class="p">:</span><span class="n">port_number</span><span class="p">()},</span>

<span class="c">%% Client certificate.</span>
<span class="n">cert</span><span class="w"> </span><span class="s">::</span><span class="w"> </span><span class="s">undefined</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="nb">binary</span><span class="p">(),</span>

<span class="c">%% HTTP/3 state machine.</span>
<span class="n">http3_machine</span><span class="w"> </span><span class="s">::</span><span class="w"> </span><span class="s">cow_http3_machine:http3_machine(),</span>

<span class="c">%% Specially handled local unidi streams.</span>
<span class="n">local_control_id</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="n">undefined</span><span class="w"> </span><span class="p">::</span><span class="w"> </span><span class="n">undefined</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">cow_http3</span><span class="p">:</span><span class="n">stream_id</span><span class="p">(),</span>
<span class="n">local_encoder_id</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="n">undefined</span><span class="w"> </span><span class="p">::</span><span class="w"> </span><span class="n">undefined</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">cow_http3</span><span class="p">:</span><span class="n">stream_id</span><span class="p">(),</span>
<span class="n">local_decoder_id</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="n">undefined</span><span class="w"> </span><span class="p">::</span><span class="w"> </span><span class="n">undefined</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">cow_http3</span><span class="p">:</span><span class="n">stream_id</span><span class="p">(),</span>

<span class="c">%% Bidirectional streams used for requests and responses,</span>
<span class="c">%% as well as unidirectional streams initiated by the client.</span>
<span class="n">streams</span><span class="w"> </span><span class="p">=</span><span class="w"> </span>#<span class="p">{}</span><span class="w"> </span><span class="p">::</span><span class="w"> </span>#<span class="p">{</span><span class="n">cow_http3</span><span class="p">:</span><span class="n">stream_id</span><span class="p">()</span><span class="w"> </span><span class="p">=</span><span class="o">&gt;</span><span class="w"> </span>#<span class="n">stream</span><span class="p">{}},</span>

<span class="c">%% Lingering streams that were recently reset. We may receive</span>
<span class="c">%% pending data or messages for these streams a short while</span>
<span class="c">%% after they have been reset.</span>
<span class="n">lingering_streams</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="p">[]</span><span class="w"> </span><span class="p">::</span><span class="w"> </span><span class="p">[</span><span class="n">non_neg_integer</span><span class="p">()],</span>

<span class="c">%% Streams can spawn zero or more children which are then managed</span>
<span class="c">%% by this module if operating as a supervisor.</span>
<span class="n">children</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="n">cowboy_children</span><span class="p">:</span><span class="n">init</span><span class="p">()</span><span class="w"> </span><span class="p">::</span><span class="w"> </span><span class="n">cowboy_children</span><span class="p">:</span><span class="n">children</span><span class="p">()</span>
</code></pre></div>

<p>}).</p>
<p>-spec init(pid(), ranch:ref(), cowboy_quicer:quicer_connection_handle(), opts())
    -&gt; no_return().
- <code>loop(State0=#state{opts=Opts, children=Children})</code> - Immediately open a control, encoder and decoder stream.
    %% @todo An endpoint MAY avoid creating an encoder stream if it will not be used (for example, if its encoder does not wish to use the dynamic table or if the maximum size of the dynamic table permitted by the peer is zero).
    %% @todo An endpoint MAY avoid creating a decoder stream if its decoder sets the maximum capacity of the dynamic table to zero.
    {ok, ControlID} = maybe_socket_error(undefined,
        cowboy_quicer:start_unidi_stream(Conn, [&lt;&lt;0&gt;&gt;, SettingsBin]),
        'A socket error occurred when opening the control stream.'),
    {ok, EncoderID} = maybe_socket_error(undefined,
        cowboy_quicer:start_unidi_stream(Conn, &lt;&lt;2&gt;&gt;),
        'A socket error occurred when opening the encoder stream.'),
    {ok, DecoderID} = maybe_socket_error(undefined,
        cowboy_quicer:start_unidi_stream(Conn, &lt;&lt;3&gt;&gt;),
        'A socket error occurred when opening the encoder stream.'),
    %% Set the control, encoder and decoder streams in the machine.
    HTTP3Machine = cow_http3_machine:init_unidi_local_streams(
        ControlID, EncoderID, DecoderID, HTTP3Machine0),
    %% Get the peername/sockname/cert.
    {ok, Peer} = maybe_socket_error(undefined, cowboy_quicer:peername(Conn),
        'A socket error occurred when retrieving the peer name.'),
    {ok, Sock} = maybe_socket_error(undefined, cowboy_quicer:sockname(Conn),
        'A socket error occurred when retrieving the sock name.'),
    CertResult = case cowboy_quicer:peercert(Conn) of
        {error, no_peercert} -&gt;
            {ok, undefined};
        Cert0 -&gt;
            Cert0
    end,
    {ok, Cert} = maybe_socket_error(undefined, CertResult,
        'A socket error occurred when retrieving the client TLS certificate.'),
    %% Quick! Let's go!
    loop(#state{parent=Parent, ref=Ref, conn=Conn,
        opts=Opts, peer=Peer, sock=Sock, cert=Cert,
        http3_machine=HTTP3Machine, local_control_id=ControlID,
        local_encoder_id=EncoderID, local_decoder_id=DecoderID}).
- <code>handle_quic_msg(State0=#state{opts=Opts}, Msg)</code> - Timeouts.
        {timeout, Ref, {shutdown, Pid}} -&gt;
            cowboy_children:shutdown_timeout(Children, Ref, Pid),
            loop(State0);
        %% Messages pertaining to a stream.
        {{Pid, StreamID}, Msg} when Pid =:= self() -&gt;
            loop(info(State0, StreamID, Msg));
        %% WebTransport commands.
        {'$webtransport_commands', SessionID, Commands} -&gt;
            loop(webtransport_commands(State0, SessionID, Commands));
        %% Exit signal from children.
        Msg = {'EXIT', Pid, <em>} -&gt;
            loop(down(State0, Pid, Msg));
        Msg -&gt;
            cowboy:log(warning, "Received stray message ~p.", [Msg], Opts),
            loop(State0)
    end.
- <code>parse(State=#state{opts=Opts}, StreamID, Data, IsFin)</code> - @todo Different error reason if graceful?
            Reason = {socket_error, closed, 'The socket has been closed.'},
            terminate(State0, Reason);
        ok -&gt;
            loop(State0);
        unknown -&gt;
            cowboy:log(warning, "Received unknown QUIC message ~p.", [Msg], Opts),
            loop(State0);
        {socket_error, Reason} -&gt;
            terminate(State0, {socket_error, Reason,
                'An error has occurred on the socket.'})
    end.
- <code>parse1(State=#state{opts=Opts}, Stream=#stream{id=StreamID}, Data, IsFin)</code> - @todo Clause that discards receiving data for stopping streams.
%%       We may receive a few more frames after we abort receiving.
- <code>is_fin(fin, &lt;&lt;&gt;&gt;)</code> - The WebTransport stream header is not a real frame.
        {webtransport_stream_header, SessionID, Rest} -&gt;
            become_webtransport_stream(State, Stream, bidi, SessionID, Rest, IsFin);
        {more, Frame = {data, </em>}, Len} -&gt;
            %% We're at the end of the data so FrameIsFin is equivalent to IsFin.
            case IsFin of
                nofin -&gt;
                    %% The stream will be stored at the end of processing commands.
                    loop(frame(State, Stream#stream{status={data, Len}}, Frame, nofin));
                fin -&gt;
                    terminate(State, {connection_error, h3_frame_error,
                        'Last frame on stream was truncated. (RFC9114 7.1)'})
            end;
        {more, ignore, Len} -&gt;
            %% @todo This setting should be tested.
            %%
            %% While the default value doesn't warrant doing a streaming ignore
            %% (and could work just fine with the 'more' clause), this value
            %% is configurable and users may want to set it large.
            MaxIgnoredLen = maps:get(max_ignored_frame_size_received, Opts, 16384),
            %% We're at the end of the data so FrameIsFin is equivalent to IsFin.
            case IsFin of
                nofin when Len &lt; MaxIgnoredLen -&gt;
                    %% We are not processing commands so we must store the stream.
                    %% We also call ignored_frame here; we will not need to call
                    %% it again when ignoring the rest of the data.
                    Stream1 = Stream#stream{status={ignore, Len}},
                    State1 = ignored_frame(State, Stream1),
                    loop(stream_store(State1, Stream1));
                nofin -&gt;
                    terminate(State, {connection_error, h3_excessive_load,
                        'Ignored frame larger than limit. (RFC9114 10.5)'});
                fin -&gt;
                    terminate(State, {connection_error, h3_frame_error,
                        'Last frame on stream was truncated. (RFC9114 7.1)'})
            end;
        {ignore, Rest} -&gt;
            parse(ignored_frame(State, Stream), StreamID, Rest, IsFin);
        Error = {connection_error, <em>, </em>} -&gt;
            terminate(State, Error);
        more when Data =:= &lt;&lt;&gt;&gt; -&gt;
            %% The buffer was already reset to &lt;&lt;&gt;&gt;.
            loop(stream_store(State, Stream));
        more -&gt;
            %% We're at the end of the data so FrameIsFin is equivalent to IsFin.
            case IsFin of
                nofin -&gt;
                    loop(stream_store(State, Stream#stream{buffer=Data}));
                fin -&gt;
                    terminate(State, {connection_error, h3_frame_error,
                        'Last frame on stream was truncated. (RFC9114 7.1)'})
            end
    end.</p>
<p>%% We may receive multiple frames in a single QUIC packet.
%% The FIN flag applies to the QUIC packet, not to the frame.
%% We must therefore only consider the frame to have a FIN
%% flag if there's no data remaining to be read.
- <code>frame(State=#state{http3_machine=HTTP3Machine0},
        Stream=#stream{id=StreamID}, Frame, IsFin)</code> - @todo Perhaps do this in cow_http3_machine directly.
        {ok, push, <em>} -&gt;
            terminate(State0, {connection_error, h3_stream_creation_error,
                'Only servers can push. (RFC9114 6.2.2)'});
        {ok, {webtransport, SessionID}, Rest} -&gt;
            become_webtransport_stream(State0, Stream0, unidi, SessionID, Rest, IsFin);
        %% Unknown stream types must be ignored. We choose to abort the
        %% stream instead of reading and discarding the incoming data.
        {undefined, </em>} -&gt;
            loop(stream_abort_receive(State0, Stream0, h3_stream_creation_error));
        %% Very unlikely to happen but WebTransport headers may be fragmented
        %% as they are more than one byte. The fin flag in this case is an error,
        %% but because it happens in WebTransport application data (the Session ID)
        %% we only reset the impacted stream and not the entire connection.
        more when IsFin =:= fin -&gt;
            loop(stream_abort_receive(State0, Stream0, h3_stream_creation_error));
        more -&gt;
            loop(stream_store(State0, Stream0#stream{buffer=Data}))
    end.
- <code>data_frame(State=#state{opts=Opts},
        Stream=#stream{id=StreamID, state=StreamState0}, IsFin, Data)</code> - @todo Propagate trailers.
            send_instructions(State#state{http3_machine=HTTP3Machine}, Instrs);
        {ok, GoAway={goaway, <em>}, HTTP3Machine} -&gt;
            goaway(State#state{http3_machine=HTTP3Machine}, GoAway);
        {error, Error={stream_error, _Reason, _Human}, Instrs, HTTP3Machine} -&gt;
            State1 = send_instructions(State#state{http3_machine=HTTP3Machine}, Instrs),
            reset_stream(State1, Stream, Error);
        {error, Error={connection_error, </em>, <em>}, HTTP3Machine} -&gt;
            terminate(State#state{http3_machine=HTTP3Machine}, Error)
    end.
- <code>ensure_port(&lt;&lt;"http"&gt;&gt;, undefined)</code> - We add the protocol information for extended CONNECTs.
                    Req = case PseudoHeaders of
                        #{protocol := Protocol} -&gt; Req0#{protocol =&gt; Protocol};
                        _ -&gt; Req0
                    end,
                    headers_frame(State, Stream, Req)
            catch </em>:<em> -&gt;
                reset_stream(State, Stream, {stream_error, h3_message_error,
                    'The :path pseudo-header is invalid. (RFC7540 8.1.2.3)'})
            end
    catch </em>:_ -&gt;
        reset_stream(State, Stream, {stream_error, h3_message_error,
            'The :authority pseudo-header is invalid. (RFC7540 8.1.2.3)'})
    end.</p>
<p>%% @todo Copied from cowboy_http2.
%% @todo How to handle "http"?
- <code>headers_to_map([], Acc)</code> - @todo Copied from cowboy_http2.
%% This function is necessary to properly handle duplicate headers
%% and the special-case cookie header.
- <code>headers_frame(State=#state{opts=Opts}, Stream=#stream{id=StreamID}, Req)</code> - The cookie header does not use proper HTTP header lists.
        #{Name := Value0} when Name =:= &lt;&lt;"cookie"&gt;&gt; -&gt;
            Acc0#{Name =&gt; &lt;&lt; Value0/binary, "; ", Value/binary &gt;&gt;};
        #{Name := Value0} -&gt;
            Acc0#{Name =&gt; &lt;&lt; Value0/binary, ", ", Value/binary &gt;&gt;};
        _ -&gt;
            Acc0#{Name =&gt; Value}
    end,
    headers_to_map(Tail, Acc).</p>
<p>%% @todo WebTransport CONNECT requests must have extra checks on settings.
%% @todo We may also need to defer them if we didn't get settings.
- <code>parse_datagram(State, Data0)</code> - We automatically terminate the stream but it is not an error
    %% per se (at least not in the first implementation).
    Reason = {stream_error, h3_no_error, HumanReadable},
    %% The partial Req is minimal for now. We only have one case
    %% where it can be called (when a method is completely disabled).
    PartialReq = #{
        ref =&gt; Ref,
        peer =&gt; Peer,
        method =&gt; Method,
        headers =&gt; headers_to_map(Headers, #{})
    },
    Resp = {response, StatusCode0, RespHeaders0=#{&lt;&lt;"content-length"&gt;&gt; =&gt; &lt;&lt;"0"&gt;&gt;}, &lt;&lt;&gt;&gt;},
    try cowboy_stream:early_error(StreamID, Reason, PartialReq, Resp, Opts) of
        {response, StatusCode, RespHeaders, RespBody} -&gt;
            send_response(State0, Stream, StatusCode, RespHeaders, RespBody)
    catch Class:Exception:Stacktrace -&gt;
        cowboy:log(cowboy_stream:make_error_log(early_error,
            [StreamID, Reason, PartialReq, Resp, Opts],
            Class, Exception, Stacktrace), Opts),
        %% We still need to send an error response, so send what we initially
        %% wanted to send. It's better than nothing.
        send_headers(State0, Stream, fin, StatusCode0, RespHeaders0)
    end.</p>
<p>%% Datagrams.
- <code>down(State0=#state{opts=Opts, children=Children0}, Pid, Msg)</code> - @todo Might be a future WT session or an error.
    end.</p>
<p>%% Erlang messages.
- <code>info(State=#state{opts=Opts, http3_machine=_HTTP3Machine}, StreamID, Msg)</code> - The stream was terminated already.
        {ok, undefined, Children} -&gt;
            State0#state{children=Children};
        %% The stream is still running.
        {ok, StreamID, Children} -&gt;
            info(State0#state{children=Children}, StreamID, Msg);
        %% The process was unknown.
        error -&gt;
            cowboy:log(warning, "Received EXIT signal ~p for unknown process ~p.~n",
                [Msg, Pid], Opts),
            State0
    end,
    if
%% @todo
%       State#state.http2_status =:= closing, State#state.streams =:= #{} -&gt;
%           terminate(State, {stop, normal, 'The connection is going away.'});
        true -&gt;
            State
    end.
- <code>commands(State=#state{opts=Opts}, Stream, [Log={log, _, _, _}|Tail])</code> - @todo Do we want to run the commands after a stop?
    %% @todo Do we even allow commands after?
    stop_stream(State, Stream);
%% Log event.
- <code>maybe_send_is_fin(State=#state{http3_machine=HTTP3Machine0},
        Stream=#stream{id=StreamID}, fin)</code> - @todo Add a test for HEAD to make sure we don't send the body when
            %% returning {response...} from a stream handler (or {headers...} then {data...}).
            {ok, <em>IsFin, HeaderBlock, Instrs, HTTP3Machine}
                = cow_http3_machine:prepare_headers(StreamID, HTTP3Machine0, nofin,
                    #{status =&gt; cow_http:status_to_integer(StatusCode)},
                    headers_to_list(Headers)),
            State = send_instructions(State0#state{http3_machine=HTTP3Machine}, Instrs),
            %% @todo It might be better to do async sends.
            _ = case Body of
                {sendfile, Offset, Bytes, Path} -&gt;
                    ok = maybe_socket_error(State,
                        cowboy_quicer:send(Conn, StreamID, cow_http3:headers(HeaderBlock))),
                    %% Temporary solution to do sendfile over QUIC.
                    {ok, </em>} = maybe_socket_error(State,
                        ranch_transport:sendfile(?MODULE, {Conn, StreamID},
                            Path, Offset, Bytes, [])),
                    ok = maybe_socket_error(State,
                        cowboy_quicer:send(Conn, StreamID, cow_http3:data(&lt;&lt;&gt;&gt;), fin));
                _ -&gt;
                    ok = maybe_socket_error(State,
                        cowboy_quicer:send(Conn, StreamID, [
                            cow_http3:headers(HeaderBlock),
                            cow_http3:data(Body)
                        ], fin))
            end,
            maybe_send_is_fin(State, Stream, fin)
    end.
- <code>send({Conn, StreamID}, IoData)</code> - Temporary callback to do sendfile over QUIC.
-spec send({cowboy_quicer:quicer_connection_handle(), cow_http3:stream_id()},
    iodata()) -&gt; ok | {error, any()}.
- <code>headers_to_list(Headers0=#{&lt;&lt;"set-cookie"&gt;&gt; := SetCookies})</code> - The set-cookie header is special; we can only send one cookie per header.
- <code>send_instructions(State=#state{conn=Conn, local_encoder_id=EncoderID},
        {encoder_instructions, EncData})</code> - Encoder instructions.
- <code>become_webtransport_stream(State0=#state{http3_machine=HTTP3Machine0},
        Stream0=#stream{id=StreamID}, StreamType, SessionID, Rest, IsFin)</code> - We mark the stream as being a WebTransport stream
%% and then continue parsing the data as a WebTransport
%% stream. This function is common for incoming unidi
%% and bidi streams.
- <code>webtransport_event(State, SessionID, Event)</code> - We don't need to parse the remaining data if there isn't any.
            case {Rest, IsFin} of
                {&lt;&lt;&gt;&gt;, nofin} -&gt; loop(stream_store(State, Stream));
                _ -&gt; parse(stream_store(State, Stream), StreamID, Rest, IsFin)
            end
        %% @todo Error conditions.
    end.
- `wt_commands(State0=#state{conn=Conn}, Session=#stream{id=SessionID}, [Cmd|Tail])
        when Cmd =:= close; element(1, Cmd) =:= close -&gt;
    %% We must send a WT_CLOSE_SESSION capsule on the CONNECT stream.
    {AppCode, AppMsg} = case Cmd of
        close -&gt; {0, &lt;&lt;&gt;&gt;};
        {close, AppCode0} -&gt; {AppCode0, &lt;&lt;&gt;&gt;};
        {close, AppCode0, AppMsg0} -&gt; {AppCode0, AppMsg0}
    end,
    Capsule = cow_capsule:wt_close_session(AppCode, AppMsg),
    case cowboy_quicer:send(Conn, SessionID, Capsule, fin) of
        ok -&gt;
            State = webtransport_terminate_session(State0, Session),
            %% @todo Because the handler is in a separate process
            %%       we must wait for it to stop and eventually
            %%       kill the process if it takes too long.
            %% @todo We may need to fully close the CONNECT stream (if remote doesn't reset it).
            wt_commands(State, Session, Tail)
        %% @todo Handle errors.
    end.</p>
<p>webtransport_terminate_session(State=#state{conn=Conn, http3_machine=HTTP3Machine0,
        streams=Streams0, lingering_streams=Lingering0}, #stream{id=SessionID})<code>- We must send a WT_DRAIN_SESSION capsule on the CONNECT stream.
    Capsule = cow_capsule:wt_drain_session(),
    case cowboy_quicer:send(Conn, SessionID, Capsule, nofin) of
        ok -&gt;
            wt_commands(State, Session, Tail)
        %% @todo Handle errors.
    end;
-</code>stream_peer_send_shutdown(State=#state{conn=Conn}, StreamID)<code>- Reset/abort the WT streams.
    Streams = maps:filtermap(fun
        (_, #stream{id=StreamID, status={webtransport_session, _}})
                when StreamID =:= SessionID -&gt;
            %% We remove the session stream but do the shutdown outside this function.
            false;
        (StreamID, #stream{status={webtransport_stream, StreamSessionID}})
                when StreamSessionID =:= SessionID -&gt;
            cowboy_quicer:shutdown_stream(Conn, StreamID,
                both, cow_http3:error_to_code(wt_session_gone)),
            false;
        (_, _) -&gt;
            true
    end, Streams0),
    %% Keep the streams in lingering state.
    %% We only keep up to 100 streams in this state. @todo Make it configurable?
    Terminated = maps:keys(Streams0) -- maps:keys(Streams),
    Lingering = lists:sublist(Terminated ++ Lingering0, 100),
    %% Update the HTTP3 state machine.
    HTTP3Machine = cow_http3_machine:close_webtransport_session(SessionID, HTTP3Machine0),
    State#state{
        http3_machine=HTTP3Machine,
        streams=Streams,
        lingering_streams=Lingering
    }.
-</code>reset_stream(State0=#state{conn=Conn, http3_machine=HTTP3Machine0},
        Stream=#stream{id=StreamID}, Error)<code>- Cleanly terminating the CONNECT stream is equivalent
        %% to an application error code of 0 and empty message.
        Stream = #stream{status={webtransport_session, _}} -&gt;
            webtransport_event(State, StreamID, {closed, 0, &lt;&lt;&gt;&gt;}),
            %% Shutdown the CONNECT stream fully.
            cowboy_quicer:shutdown_stream(Conn, StreamID),
            webtransport_terminate_session(State, Stream);
        _ -&gt;
            State
    end.
-</code>stop_stream(State0=#state{http3_machine=HTTP3Machine}, Stream=#stream{id=StreamID})<code>- @todo Do we want to close both sides?
    %% @todo Should we close the send side if the receive side was already closed?
    cowboy_quicer:shutdown_stream(Conn, StreamID,
        both, cow_http3:error_to_code(Reason)),
    State1 = case cow_http3_machine:reset_stream(StreamID, HTTP3Machine0) of
        {ok, HTTP3Machine} -&gt;
            terminate_stream(State0#state{http3_machine=HTTP3Machine}, Stream, Error);
        {error, not_found} -&gt;
            terminate_stream(State0, Stream, Error)
    end,
%% @todo
%   case reset_rate(State1) of
%       {ok, State} -&gt;
%           State;
%       error -&gt;
%           terminate(State1, {connection_error, enhance_your_calm,
%               'Stream reset rate larger than configuration allows. Flood? (CVE-2019-9514)'})
%   end.
    State1.
-</code>maybe_terminate_stream(State, <em>)<code>- The Stream will be stored in the State at the end of commands processing.
-</code>goaway(State, {goaway, </em>})<code>- @todo Graceful connection shutdown.
%% We terminate the connection immediately if it hasn't fully been initialized.
-spec goaway(#state{}, {goaway, _}) -&gt; no_return().
-</code>maybe_socket_error(State, {error, closed})<code>- Function copied from cowboy_http.
-</code>terminate_reason({connection_error, Reason, <em>})<code>- @todo
%           %% We are terminating so it's OK if we can't send the GOAWAY anymore.
%           _ = cowboy_quicer:send(Conn, ControlID, cow_http3:goaway(
%               cow_http3_machine:get_last_streamid(HTTP3Machine))),
        %% We already sent the GOAWAY frame.
%       Status =:= closing -&gt;
%           ok
%   end,
    terminate_all_streams(State, maps:to_list(Streams), Reason),
    cowboy_children:terminate(Children),
%   terminate_linger(State),
    _ = cowboy_quicer:shutdown(Conn, cow_http3:error_to_code(terminate_reason(Reason))),
    exit({shutdown, Reason}).
-</code>stream_closed(State=#state{local_control_id=StreamID}, StreamID, </em>)<code>- Stream closed message for a local (write-only) unidi stream.
-</code>stream_closed1(State=#state{http3_machine=HTTP3Machine0}, StreamID)<code>- In the WT session's case, streams will be
        %% removed in webtransport_terminate_session.
        {Stream=#stream{status={webtransport_session, _}}, _} -&gt;
            webtransport_event(State, StreamID, closed_abruptly),
            webtransport_terminate_session(State, Stream);
        {#stream{state=undefined}, Streams} -&gt;
            %% Unidi stream has no handler/children.
            stream_closed1(State#state{streams=Streams}, StreamID);
        %% We only stop bidi streams if the stream was closed with an error
        %% or the stream was already in the process of stopping.
        {#stream{status=Status, state=StreamState}, Streams}
                when Status =:= stopping; ErrorCode =/= 0 -&gt;
            terminate_stream_handler(State, StreamID, closed, StreamState),
            Children = cowboy_children:shutdown(Children0, StreamID),
            stream_closed1(State#state{streams=Streams, children=Children}, StreamID);
        %% Don't remove a stream that terminated properly but
        %% has chosen to remain up (custom stream handlers).
        {_, _} -&gt;
            stream_closed1(State, StreamID);
        %% Stream closed message for a stream that has been reset. Ignore.
        error -&gt;
            case is_lingering_stream(State, StreamID) of
                true -&gt;
                    ok;
                false -&gt;
                    %% We avoid logging the data as it could be quite large.
                    cowboy:log(warning, "Received stream_closed for unknown stream ~p. ~p ~p",
                        [StreamID, self(), Streams0], Opts)
            end,
            State
    end.
-</code>is_lingering_stream(#state{lingering_streams=Lingering}, StreamID)` - We only keep up to 100 streams in this state. @todo Make it configurable?
    Lingering = [StreamID|lists:sublist(Lingering0, 100 - 1)],
    State#state{lingering_streams=Lingering}.</p>
<p><strong>Dependencies</strong>: cowboy_tracer_h, cowboy_req, cowboy_middleware, cowboy_stream, cowboy_quicer, cowboy_children, cowboy, cowboy_metrics_h</p>
<hr />
<h3 id="cowboy_loop">cowboy_loop</h3>
<p><strong>File</strong>: <code>/Users/ddleon/.erlviz/cache/ninenines_cowboy/src/cowboy_loop.erl</code></p>
<p><strong>Behaviors</strong>: cowboy_sub_protocol</p>
<p><strong>Description</strong>:
Copyright (c) Loïc Hoguin <a href="&#109;&#97;&#105;&#108;&#116;&#111;&#58;&#101;&#115;&#115;&#101;&#110;&#64;&#110;&#105;&#110;&#101;&#110;&#105;&#110;&#101;&#115;&#46;&#101;&#117;">&#101;&#115;&#115;&#101;&#110;&#64;&#110;&#105;&#110;&#101;&#110;&#105;&#110;&#101;&#115;&#46;&#101;&#117;</a>
%% Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted, provided that the above
copyright notice and this permission notice appear in all copies.
%% THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF</p>
<p><strong>Exported Functions</strong>: upgrade/4, upgrade/5, loop/5, system_continue/3, system_terminate/4, system_code_change/4</p>
<p><strong>Functions</strong>:</p>
<ul>
<li><code>upgrade(Req, Env, Handler, HandlerState)</code> - Copyright (c) Loïc Hoguin <a href="&#109;&#97;&#105;&#108;&#116;&#111;&#58;&#101;&#115;&#115;&#101;&#110;&#64;&#110;&#105;&#110;&#101;&#110;&#105;&#110;&#101;&#115;&#46;&#101;&#117;">&#101;&#115;&#115;&#101;&#110;&#64;&#110;&#105;&#110;&#101;&#110;&#105;&#110;&#101;&#115;&#46;&#101;&#117;</a>
%%
%% Permission to use, copy, modify, and/or distribute this software for any
%% purpose with or without fee is hereby granted, provided that the above
%% copyright notice and this permission notice appear in all copies.
%%
%% THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
%% WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
%% MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
%% ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
%% WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
%% ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
%% OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.</li>
</ul>
<p>-module(cowboy_loop).
-behaviour(cowboy_sub_protocol).</p>
<p>-export([upgrade/4]).
-export([upgrade/5]).
-export([loop/5]).</p>
<p>-export([system_continue/3]).
-export([system_terminate/4]).
-export([system_code_change/4]).</p>
<p>%% From gen_server.
-define(is_timeout(X), ((X) =:= infinity orelse (is_integer(X) andalso (X) &gt;= 0))).</p>
<p>-callback init(Req, any())
    -&gt; {ok | module(), Req, any()}
    | {module(), Req, any(), any()}
    when Req::cowboy_req:req().</p>
<p>-callback info(any(), Req, State)
    -&gt; {ok, Req, State}
    | {ok, Req, State, hibernate}
    | {stop, Req, State}
    when Req::cowboy_req:req(), State::any().</p>
<p>-callback terminate(any(), cowboy_req:req(), any()) -&gt; ok.
-optional_callbacks([terminate/3]).</p>
<p>-spec upgrade(Req, Env, module(), any())
    -&gt; {ok, Req, Env} | {suspend, ?MODULE, loop, [any()]}
    when Req::cowboy_req:req(), Env::cowboy_middleware:env().
- <code>loop(Req=#{pid := Parent}, Env, Handler, HandlerState, Timeout)</code> - @todo Handle system messages.
- <code>call(Req0, Env, Handler, HandlerState0, Timeout, Message)</code> - System messages.
        {'EXIT', Parent, Reason} -&gt;
            terminate(Req, Env, Handler, HandlerState, Reason);
        {system, From, Request} -&gt;
            sys:handle_system_msg(Request, From, Parent, ?MODULE, [],
                {Req, Env, Handler, HandlerState, Timeout});
        %% Calls from supervisor module.
        {'$gen_call', From, Call} -&gt;
            cowboy_children:handle_supervisor_call(Call, From, [], ?MODULE),
            loop(Req, Env, Handler, HandlerState, Timeout);
        Message -&gt;
            call(Req, Env, Handler, HandlerState, Timeout, Message)
    after Timeout -&gt;
        call(Req, Env, Handler, HandlerState, Timeout, timeout)
    end.
- <code>system_continue(_, _, {Req, Env, Handler, HandlerState, Timeout})</code> - System callbacks.</p>
<p>-spec system_continue(<em>, </em>, {Req, Env, module(), any(), timeout()})
    -&gt; {ok, Req, Env} | {suspend, ?MODULE, loop, [any()]}
    when Req::cowboy_req:req(), Env::cowboy_middleware:env().</p>
<p><strong>Dependencies</strong>: cowboy_req, cowboy_middleware, cowboy_handler, cowboy_children</p>
<hr />
<h3 id="cowboy_metrics_h">cowboy_metrics_h</h3>
<p><strong>File</strong>: <code>/Users/ddleon/.erlviz/cache/ninenines_cowboy/src/cowboy_metrics_h.erl</code></p>
<p><strong>Behaviors</strong>: cowboy_stream</p>
<p><strong>Description</strong>:
Copyright (c) Loïc Hoguin <a href="&#109;&#97;&#105;&#108;&#116;&#111;&#58;&#101;&#115;&#115;&#101;&#110;&#64;&#110;&#105;&#110;&#101;&#110;&#105;&#110;&#101;&#115;&#46;&#101;&#117;">&#101;&#115;&#115;&#101;&#110;&#64;&#110;&#105;&#110;&#101;&#110;&#105;&#110;&#101;&#115;&#46;&#101;&#117;</a>
%% Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted, provided that the above
copyright notice and this permission notice appear in all copies.
%% THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF</p>
<p><strong>Exported Functions</strong>: init/3, data/4, info/3, terminate/3, early_error/5</p>
<p><strong>Functions</strong>:</p>
<ul>
<li><code>init(StreamID, Req=#{ref := Ref}, Opts=#{metrics_callback := Fun})</code> - Copyright (c) Loïc Hoguin <a href="&#109;&#97;&#105;&#108;&#116;&#111;&#58;&#101;&#115;&#115;&#101;&#110;&#64;&#110;&#105;&#110;&#101;&#110;&#105;&#110;&#101;&#115;&#46;&#101;&#117;">&#101;&#115;&#115;&#101;&#110;&#64;&#110;&#105;&#110;&#101;&#110;&#105;&#110;&#101;&#115;&#46;&#101;&#117;</a>
%%
%% Permission to use, copy, modify, and/or distribute this software for any
%% purpose with or without fee is hereby granted, provided that the above
%% copyright notice and this permission notice appear in all copies.
%%
%% THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
%% WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
%% MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
%% ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
%% WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
%% ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
%% OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.</li>
</ul>
<p>-module(cowboy_metrics_h).
-behavior(cowboy_stream).</p>
<p>-export([init/3]).
-export([data/4]).
-export([info/3]).
-export([terminate/3]).
-export([early_error/5]).</p>
<p>-type proc_metrics() :: #{pid() =&gt; #{
    %% Time at which the process spawned.
    spawn := integer(),</p>
<div class="codehilite"><pre><span></span><code><span class="c">%% Time at which the process exited.</span>
<span class="nb">exit</span><span class="w"> </span><span class="p">=</span><span class="o">&gt;</span><span class="w"> </span><span class="n">integer</span><span class="p">(),</span>

<span class="c">%% Reason for the process exit.</span>
<span class="n">reason</span><span class="w"> </span><span class="p">=</span><span class="o">&gt;</span><span class="w"> </span><span class="nb">any</span><span class="p">()</span>
</code></pre></div>

<p>}}.</p>
<p>-type informational_metrics() :: #{
    %% Informational response status.
    status := cowboy:http_status(),</p>
<div class="codehilite"><pre><span></span><code><span class="c">%% Headers sent with the informational response.</span>
<span class="n">headers</span><span class="w"> </span><span class="s">:=</span><span class="w"> </span><span class="s">cowboy:http_headers(),</span>

<span class="c">%% Time when the informational response was sent.</span>
<span class="nb">time</span><span class="w"> </span><span class="p">:=</span><span class="w"> </span><span class="n">integer</span><span class="p">()</span>
</code></pre></div>

<p>}.</p>
<p>-type metrics() :: #{
    %% The identifier for this listener.
    ref := ranch:ref(),</p>
<div class="codehilite"><pre><span></span><code><span class="c">%% The pid for this connection.</span>
<span class="n">pid</span><span class="w"> </span><span class="s">:=</span><span class="w"> </span><span class="s">pid(),</span>

<span class="c">%% The streamid also indicates the total number of requests on</span>
<span class="c">%% this connection (StreamID div 2 + 1).</span>
<span class="n">streamid</span><span class="w"> </span><span class="s">:=</span><span class="w"> </span><span class="s">cowboy_stream:streamid(),</span>

<span class="c">%% The terminate reason is always useful.</span>
<span class="n">reason</span><span class="w"> </span><span class="s">:=</span><span class="w"> </span><span class="s">cowboy_stream:reason(),</span>

<span class="c">%% A filtered Req object or a partial Req object</span>
<span class="c">%% depending on how far the request got to.</span>
<span class="n">req</span><span class="w"> </span><span class="p">=</span><span class="o">&gt;</span><span class="w"> </span><span class="n">cowboy_req</span><span class="p">:</span><span class="n">req</span><span class="p">(),</span>
<span class="n">partial_req</span><span class="w"> </span><span class="p">=</span><span class="o">&gt;</span><span class="w"> </span><span class="n">cowboy_stream</span><span class="p">:</span><span class="n">partial_req</span><span class="p">(),</span>

<span class="c">%% Response status.</span>
<span class="n">resp_status</span><span class="w"> </span><span class="s">:=</span><span class="w"> </span><span class="s">cowboy:http_status(),</span>

<span class="c">%% Filtered response headers.</span>
<span class="n">resp_headers</span><span class="w"> </span><span class="s">:=</span><span class="w"> </span><span class="s">cowboy:http_headers(),</span>

<span class="c">%% Start/end of the processing of the request.</span>
<span class="c">%%</span>
<span class="c">%% This represents the time from this stream handler&#39;s init</span>
<span class="c">%% to terminate.</span>
<span class="n">req_start</span><span class="w"> </span><span class="p">=</span><span class="o">&gt;</span><span class="w"> </span><span class="n">integer</span><span class="p">(),</span>
<span class="n">req_end</span><span class="w"> </span><span class="p">=</span><span class="o">&gt;</span><span class="w"> </span><span class="n">integer</span><span class="p">(),</span>

<span class="c">%% Start/end of the receiving of the request body.</span>
<span class="c">%% Begins when the first packet has been received.</span>
<span class="n">req_body_start</span><span class="w"> </span><span class="p">=</span><span class="o">&gt;</span><span class="w"> </span><span class="n">integer</span><span class="p">(),</span>
<span class="n">req_body_end</span><span class="w"> </span><span class="p">=</span><span class="o">&gt;</span><span class="w"> </span><span class="n">integer</span><span class="p">(),</span>

<span class="c">%% Start/end of the sending of the response.</span>
<span class="c">%% Begins when we send the headers and ends on the final</span>
<span class="c">%% packet of the response body. If everything is sent at</span>
<span class="c">%% once these values are identical.</span>
<span class="n">resp_start</span><span class="w"> </span><span class="p">=</span><span class="o">&gt;</span><span class="w"> </span><span class="n">integer</span><span class="p">(),</span>
<span class="n">resp_end</span><span class="w"> </span><span class="p">=</span><span class="o">&gt;</span><span class="w"> </span><span class="n">integer</span><span class="p">(),</span>

<span class="c">%% For early errors all we get is the time we received it.</span>
<span class="n">early_error_time</span><span class="w"> </span><span class="p">=</span><span class="o">&gt;</span><span class="w"> </span><span class="n">integer</span><span class="p">(),</span>

<span class="c">%% Start/end of spawned processes. This is where most of</span>
<span class="c">%% the user code lies, excluding stream handlers. On a</span>
<span class="c">%% default Cowboy configuration there should be only one</span>
<span class="c">%% process: the request process.</span>
<span class="n">procs</span><span class="w"> </span><span class="p">=</span><span class="o">&gt;</span><span class="w"> </span><span class="n">proc_metrics</span><span class="p">(),</span>

<span class="c">%% Informational responses sent before the final response.</span>
<span class="n">informational</span><span class="w"> </span><span class="p">=</span><span class="o">&gt;</span><span class="w"> </span><span class="p">[</span><span class="n">informational_metrics</span><span class="p">()],</span>

<span class="c">%% Length of the request and response bodies. This does</span>
<span class="c">%% not include the framing.</span>
<span class="n">req_body_length</span><span class="w"> </span><span class="p">=</span><span class="o">&gt;</span><span class="w"> </span><span class="n">non_neg_integer</span><span class="p">(),</span>
<span class="n">resp_body_length</span><span class="w"> </span><span class="p">=</span><span class="o">&gt;</span><span class="w"> </span><span class="n">non_neg_integer</span><span class="p">(),</span>

<span class="c">%% Additional metadata set by the user.</span>
<span class="n">user_data</span><span class="w"> </span><span class="p">=</span><span class="o">&gt;</span><span class="w"> </span><span class="n">map</span><span class="p">()</span>
</code></pre></div>

<p>}.
-export_type([metrics/0]).</p>
<p>-type metrics_callback() :: fun((metrics()) -&gt; any()).
-export_type([metrics_callback/0]).</p>
<p>-record(state, {
    next :: any(),
    callback :: fun((metrics()) -&gt; any()),
    resp_headers_filter :: undefined | fun((cowboy:http_headers()) -&gt; cowboy:http_headers()),
    req :: map(),
    resp_status :: undefined | cowboy:http_status(),
    resp_headers :: undefined | cowboy:http_headers(),
    ref :: ranch:ref(),
    req_start :: integer(),
    req_end :: undefined | integer(),
    req_body_start :: undefined | integer(),
    req_body_end :: undefined | integer(),
    resp_start :: undefined | integer(),
    resp_end :: undefined | integer(),
    procs = #{} :: proc_metrics(),
    informational = [] :: [informational_metrics()],
    req_body_length = 0 :: non_neg_integer(),
    resp_body_length = 0 :: non_neg_integer(),
    user_data = #{} :: map()
}).</p>
<p>-spec init(cowboy_stream:streamid(), cowboy_req:req(), cowboy:opts())
    -&gt; {[{spawn, pid(), timeout()}], #state{}}.
- <code>fold([{data, nofin, Data}|Tail], State=#state{resp_body_length=RespBodyLen})</code> - @todo It might be worthwhile to keep the sendfile information around,
%% especially if these frames ultimately result in a sendfile syscall.
- <code>resp_body_length({sendfile, _, Len, _})</code> - As far as metrics go we are limited in what we can provide
    %% in this case.
    Metrics = #{
        ref =&gt; Ref,
        pid =&gt; self(),
        streamid =&gt; StreamID,
        reason =&gt; Reason,
        partial_req =&gt; PartialReq,
        resp_status =&gt; RespStatus,
        resp_headers =&gt; RespHeaders,
        early_error_time =&gt; Time,
        resp_body_length =&gt; resp_body_length(RespBody)
    },
    Fun(Metrics),
    Resp.</p>
<p><strong>Dependencies</strong>: cowboy, cowboy_stream, cowboy_req</p>
<hr />
<h3 id="cowboy_middleware">cowboy_middleware</h3>
<p><strong>File</strong>: <code>/Users/ddleon/.erlviz/cache/ninenines_cowboy/src/cowboy_middleware.erl</code></p>
<p><strong>Description</strong>:
Copyright (c) Loïc Hoguin <a href="&#109;&#97;&#105;&#108;&#116;&#111;&#58;&#101;&#115;&#115;&#101;&#110;&#64;&#110;&#105;&#110;&#101;&#110;&#105;&#110;&#101;&#115;&#46;&#101;&#117;">&#101;&#115;&#115;&#101;&#110;&#64;&#110;&#105;&#110;&#101;&#110;&#105;&#110;&#101;&#115;&#46;&#101;&#117;</a>
%% Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted, provided that the above
copyright notice and this permission notice appear in all copies.
%% THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF</p>
<p><strong>Dependencies</strong>: cowboy_req</p>
<hr />
<h3 id="cowboy_quicer">cowboy_quicer</h3>
<p><strong>File</strong>: <code>/Users/ddleon/.erlviz/cache/ninenines_cowboy/src/cowboy_quicer.erl</code></p>
<p><strong>Description</strong>:
Copyright (c) Loïc Hoguin <a href="&#109;&#97;&#105;&#108;&#116;&#111;&#58;&#101;&#115;&#115;&#101;&#110;&#64;&#110;&#105;&#110;&#101;&#110;&#105;&#110;&#101;&#115;&#46;&#101;&#117;">&#101;&#115;&#115;&#101;&#110;&#64;&#110;&#105;&#110;&#101;&#110;&#105;&#110;&#101;&#115;&#46;&#101;&#117;</a>
%% Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted, provided that the above
copyright notice and this permission notice appear in all copies.
%% THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF</p>
<p><strong>Exported Functions</strong>: peername/1, sockname/1, peercert/1, shutdown/2, start_bidi_stream/2, start_unidi_stream/2, send/3, send/4, send_datagram/2, shutdown_stream/2 ... (+2 more)</p>
<p><strong>Functions</strong>:</p>
<ul>
<li><code>peername(Conn)</code> - @todo Make quicer export these types.
-type quicer_connection_handle() :: reference().
-export_type([quicer_connection_handle/0]).</li>
</ul>
<p>-type quicer_app_errno() :: non_neg_integer().</p>
<p>-include_lib("quicer/include/quicer.hrl").</p>
<p>%% Connection.</p>
<p>-spec peername(quicer_connection_handle())
    -&gt; {ok, {inet:ip_address(), inet:port_number()}}
    | {error, any()}.
- <code>start_bidi_stream(Conn, InitialData)</code> - Streams.</p>
<p>-spec start_bidi_stream(quicer_connection_handle(), iodata())
    -&gt; {ok, cow_http3:stream_id()}
    | {error, any()}.
- <code>shutdown_stream(_Conn, StreamID)</code> - @todo Fix/ignore the Dialyzer error instead of doing this.
    DataBin = iolist_to_binary(Data),
    Size = byte_size(DataBin),
    case quicer:send_dgram(Conn, DataBin) of
        {ok, Size} -&gt;
            ok;
        %% @todo Handle error cases.
        Error -&gt;
            Error
    end.</p>
<p>-spec shutdown_stream(quicer_connection_handle(), cow_http3:stream_id())
    -&gt; ok.
- <code>shutdown_flag(both)</code> - @todo Are these flags correct for what we want?
- <code>handle({quic, transport_shutdown, _Conn, _Flags})</code> - QUIC_CONNECTION_EVENT_SHUTDOWN_INITIATED_BY_TRANSPORT</p>
<hr />
<h3 id="cowboy_req">cowboy_req</h3>
<p><strong>File</strong>: <code>/Users/ddleon/.erlviz/cache/ninenines_cowboy/src/cowboy_req.erl</code></p>
<p><strong>Description</strong>:
Copyright (c) Loïc Hoguin <a href="&#109;&#97;&#105;&#108;&#116;&#111;&#58;&#101;&#115;&#115;&#101;&#110;&#64;&#110;&#105;&#110;&#101;&#110;&#105;&#110;&#101;&#115;&#46;&#101;&#117;">&#101;&#115;&#115;&#101;&#110;&#64;&#110;&#105;&#110;&#101;&#110;&#105;&#110;&#101;&#115;&#46;&#101;&#117;</a>
Copyright (c) Anthony Ramine <a href="&#109;&#97;&#105;&#108;&#116;&#111;&#58;&#110;&#111;&#120;&#64;&#100;&#101;&#118;&#45;&#101;&#120;&#116;&#101;&#110;&#100;&#46;&#101;&#117;">&#110;&#111;&#120;&#64;&#100;&#101;&#118;&#45;&#101;&#120;&#116;&#101;&#110;&#100;&#46;&#101;&#117;</a>
%% Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted, provided that the above
copyright notice and this permission notice appear in all copies.
%% THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN</p>
<p><strong>Exported Functions</strong>: method/1, version/1, peer/1, sock/1, cert/1, scheme/1, host/1, host_info/1, port/1, path/1 ... (+54 more)</p>
<p><strong>Functions</strong>:</p>
<ul>
<li><code>method(#{method := Method})</code> - Copyright (c) Loïc Hoguin <a href="&#109;&#97;&#105;&#108;&#116;&#111;&#58;&#101;&#115;&#115;&#101;&#110;&#64;&#110;&#105;&#110;&#101;&#110;&#105;&#110;&#101;&#115;&#46;&#101;&#117;">&#101;&#115;&#115;&#101;&#110;&#64;&#110;&#105;&#110;&#101;&#110;&#105;&#110;&#101;&#115;&#46;&#101;&#117;</a>
%% Copyright (c) Anthony Ramine <a href="&#109;&#97;&#105;&#108;&#116;&#111;&#58;&#110;&#111;&#120;&#64;&#100;&#101;&#118;&#45;&#101;&#120;&#116;&#101;&#110;&#100;&#46;&#101;&#117;">&#110;&#111;&#120;&#64;&#100;&#101;&#118;&#45;&#101;&#120;&#116;&#101;&#110;&#100;&#46;&#101;&#117;</a>
%%
%% Permission to use, copy, modify, and/or distribute this software for any
%% purpose with or without fee is hereby granted, provided that the above
%% copyright notice and this permission notice appear in all copies.
%%
%% THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
%% WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
%% MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
%% ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
%% WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
%% ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
%% OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.</li>
</ul>
<p>-module(cowboy_req).</p>
<p>%% Request.
-export([method/1]).
-export([version/1]).
-export([peer/1]).
-export([sock/1]).
-export([cert/1]).
-export([scheme/1]).
-export([host/1]).
-export([host_info/1]).
-export([port/1]).
-export([path/1]).
-export([path_info/1]).
-export([qs/1]).
-export([parse_qs/1]).
-export([match_qs/2]).
-export([uri/1]).
-export([uri/2]).
-export([binding/2]).
-export([binding/3]).
-export([bindings/1]).
-export([header/2]).
-export([header/3]).
-export([headers/1]).
-export([parse_header/2]).
-export([parse_header/3]).
-export([filter_cookies/2]).
-export([parse_cookies/1]).
-export([match_cookies/2]).</p>
<p>%% Request body.
-export([has_body/1]).
-export([body_length/1]).
-export([read_body/1]).
-export([read_body/2]).
-export([read_urlencoded_body/1]).
-export([read_urlencoded_body/2]).
-export([read_and_match_urlencoded_body/2]).
-export([read_and_match_urlencoded_body/3]).</p>
<p>%% Multipart.
-export([read_part/1]).
-export([read_part/2]).
-export([read_part_body/1]).
-export([read_part_body/2]).</p>
<p>%% Response.
-export([set_resp_cookie/3]).
-export([set_resp_cookie/4]).
-export([resp_header/2]).
-export([resp_header/3]).
-export([resp_headers/1]).
-export([set_resp_header/3]).
-export([set_resp_headers/2]).
-export([has_resp_header/2]).
-export([delete_resp_header/2]).
-export([set_resp_body/2]).
%% @todo set_resp_body/3 with a ContentType or even Headers argument, to set content headers.
-export([has_resp_body/1]).
-export([inform/2]).
-export([inform/3]).
-export([reply/2]).
-export([reply/3]).
-export([reply/4]).
-export([stream_reply/2]).
-export([stream_reply/3]).
%% @todo stream_body/2 (nofin)
-export([stream_body/3]).
%% @todo stream_events/2 (nofin)
-export([stream_events/3]).
-export([stream_trailers/2]).
-export([push/3]).
-export([push/4]).</p>
<p>%% Stream handlers.
-export([cast/2]).</p>
<p>%% Internal.
-export([response_headers/2]).</p>
<p>-type read_body_opts() :: #{
    length =&gt; non_neg_integer() | infinity,
    period =&gt; non_neg_integer(),
    timeout =&gt; timeout()
}.
-export_type([read_body_opts/0]).</p>
<p>%% While sendfile allows a Len of 0 that means "everything past Offset",
%% Cowboy expects the real length as it is used as metadata.
-type resp_body() :: iodata()
    | {sendfile, non_neg_integer(), non_neg_integer(), file:name_all()}.
-export_type([resp_body/0]).</p>
<p>-type push_opts() :: #{
    method =&gt; binary(),
    scheme =&gt; binary(),
    host =&gt; binary(),
    port =&gt; inet:port_number(),
    qs =&gt; binary()
}.
-export_type([push_opts/0]).</p>
<p>-type req() :: #{
    %% Public interface.
    method := binary(),
    version := cowboy:http_version() | atom(),
    scheme := binary(),
    host := binary(),
    port := inet:port_number(),
    path := binary(),
    qs := binary(),
    headers := cowboy:http_headers(),
    peer := {inet:ip_address(), inet:port_number()},
    sock := {inet:ip_address(), inet:port_number()},
    cert := binary() | undefined,</p>
<div class="codehilite"><pre><span></span><code><span class="c">%% Private interface.</span>
<span class="n">ref</span><span class="w"> </span><span class="s">:=</span><span class="w"> </span><span class="s">ranch:ref(),</span>
<span class="n">pid</span><span class="w"> </span><span class="s">:=</span><span class="w"> </span><span class="s">pid(),</span>
<span class="n">streamid</span><span class="w"> </span><span class="s">:=</span><span class="w"> </span><span class="s">cowboy_stream:streamid(),</span>

<span class="n">host_info</span><span class="w"> </span><span class="p">=</span><span class="o">&gt;</span><span class="w"> </span><span class="n">cowboy_router</span><span class="p">:</span><span class="n">tokens</span><span class="p">(),</span>
<span class="n">path_info</span><span class="w"> </span><span class="p">=</span><span class="o">&gt;</span><span class="w"> </span><span class="n">cowboy_router</span><span class="p">:</span><span class="n">tokens</span><span class="p">(),</span>
<span class="n">bindings</span><span class="w"> </span><span class="p">=</span><span class="o">&gt;</span><span class="w"> </span><span class="n">cowboy_router</span><span class="p">:</span><span class="n">bindings</span><span class="p">(),</span>

<span class="n">has_body</span><span class="w"> </span><span class="s">:=</span><span class="w"> </span><span class="s">boolean(),</span>
<span class="n">body_length</span><span class="w"> </span><span class="s">:=</span><span class="w"> </span><span class="s">non_neg_integer()</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">undefined</span><span class="p">,</span>
<span class="n">has_read_body</span><span class="w"> </span><span class="p">=</span><span class="o">&gt;</span><span class="w"> </span><span class="nb">true</span><span class="p">,</span>
<span class="n">multipart</span><span class="w"> </span><span class="p">=</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="nb">binary</span><span class="p">(),</span><span class="w"> </span><span class="nb">binary</span><span class="p">()}</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">done</span><span class="p">,</span>

<span class="n">has_sent_resp</span><span class="w"> </span><span class="p">=</span><span class="o">&gt;</span><span class="w"> </span><span class="n">headers</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="nb">true</span><span class="p">,</span>
<span class="n">resp_cookies</span><span class="w"> </span><span class="p">=</span><span class="o">&gt;</span><span class="w"> </span>#<span class="p">{</span><span class="n">iodata</span><span class="p">()</span><span class="w"> </span><span class="p">=</span><span class="o">&gt;</span><span class="w"> </span><span class="n">iodata</span><span class="p">()},</span>
<span class="n">resp_headers</span><span class="w"> </span><span class="p">=</span><span class="o">&gt;</span><span class="w"> </span>#<span class="p">{</span><span class="nb">binary</span><span class="p">()</span><span class="w"> </span><span class="p">=</span><span class="o">&gt;</span><span class="w"> </span><span class="n">iodata</span><span class="p">()},</span>
<span class="n">resp_body</span><span class="w"> </span><span class="p">=</span><span class="o">&gt;</span><span class="w"> </span><span class="n">resp_body</span><span class="p">(),</span>

<span class="n">proxy_header</span><span class="w"> </span><span class="p">=</span><span class="o">&gt;</span><span class="w"> </span><span class="n">ranch_proxy_header</span><span class="p">:</span><span class="n">proxy_info</span><span class="p">(),</span>
<span class="n">media_type</span><span class="w"> </span><span class="p">=</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="nb">binary</span><span class="p">(),</span><span class="w"> </span><span class="nb">binary</span><span class="p">(),</span><span class="w"> </span><span class="p">[{</span><span class="nb">binary</span><span class="p">(),</span><span class="w"> </span><span class="nb">binary</span><span class="p">()}]},</span>
<span class="n">language</span><span class="w"> </span><span class="p">=</span><span class="o">&gt;</span><span class="w"> </span><span class="nb">binary</span><span class="p">()</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">undefined</span><span class="p">,</span>
<span class="n">charset</span><span class="w"> </span><span class="p">=</span><span class="o">&gt;</span><span class="w"> </span><span class="nb">binary</span><span class="p">()</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">undefined</span><span class="p">,</span>
<span class="n">range</span><span class="w"> </span><span class="p">=</span><span class="o">&gt;</span><span class="w"> </span><span class="p">{</span><span class="nb">binary</span><span class="p">(),</span><span class="w"> </span><span class="nb">binary</span><span class="p">()</span>
<span class="w">    </span><span class="o">|</span><span class="w"> </span><span class="p">[{</span><span class="n">non_neg_integer</span><span class="p">(),</span><span class="w"> </span><span class="n">non_neg_integer</span><span class="p">()</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">infinity</span><span class="p">}</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">neg_integer</span><span class="p">()]},</span>
<span class="n">websocket_version</span><span class="w"> </span><span class="p">=</span><span class="o">&gt;</span><span class="w"> </span><span class="mi">7</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="mi">8</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="mi">13</span><span class="p">,</span>

<span class="c">%% The user is encouraged to use the Req to store information</span>
<span class="c">%% when no better solution is available.</span>
<span class="n">_</span><span class="w"> </span><span class="p">=</span><span class="o">&gt;</span><span class="w"> </span><span class="n">_</span>
</code></pre></div>

<p>}.
-export_type([req/0]).</p>
<p>%% Request.</p>
<p>-spec method(req()) -&gt; binary().
- <code>host_info(#{host_info := HostInfo})</code> - @todo The host_info is undefined if cowboy_router isn't used. Do we want to crash?
-spec host_info(req()) -&gt; cowboy_router:tokens() | undefined.
- <code>path_info(#{path_info := PathInfo})</code> - @todo The path_info is undefined if cowboy_router isn't used. Do we want to crash?
-spec path_info(req()) -&gt; cowboy_router:tokens() | undefined.
- <code>parse_qs(#{qs := Qs})</code> - @todo Might be useful to limit the number of keys.
-spec parse_qs(req()) -&gt; [{binary(), binary() | true}].
- <code>binding(Name, Req)</code> - Disable individual components.
    &lt;&lt;"//localhost:8080/path?dummy=2785"&gt;&gt; = iolist_to_binary(uri(Req, #{scheme =&gt; undefined})),
    &lt;&lt;"/path?dummy=2785"&gt;&gt; = iolist_to_binary(uri(Req, #{host =&gt; undefined})),
    &lt;&lt;"http://localhost/path?dummy=2785"&gt;&gt; = iolist_to_binary(uri(Req, #{port =&gt; undefined})),
    &lt;&lt;"http://localhost:8080?dummy=2785"&gt;&gt; = iolist_to_binary(uri(Req, #{path =&gt; undefined})),
    &lt;&lt;"http://localhost:8080/path"&gt;&gt; = iolist_to_binary(uri(Req, #{qs =&gt; undefined})),
    &lt;&lt;"http://localhost:8080/path?dummy=2785"&gt;&gt; = iolist_to_binary(uri(Req, #{fragment =&gt; undefined})),
    &lt;&lt;"http://localhost:8080"&gt;&gt; = iolist_to_binary(uri(Req, #{path =&gt; undefined, qs =&gt; undefined})),
    &lt;&lt;&gt;&gt; = iolist_to_binary(uri(Req, #{host =&gt; undefined, path =&gt; undefined, qs =&gt; undefined})),
    %% Empty values.
    &lt;&lt;"//localhost:8080/path?dummy=2785"&gt;&gt; = iolist_to_binary(uri(Req, #{scheme =&gt; &lt;&lt;&gt;&gt;})),
    &lt;&lt;"//localhost:8080/path?dummy=2785"&gt;&gt; = iolist_to_binary(uri(Req, #{scheme =&gt; ""})),
    &lt;&lt;"//localhost:8080/path?dummy=2785"&gt;&gt; = iolist_to_binary(uri(Req, #{scheme =&gt; [&lt;&lt;&gt;&gt;]})),
    &lt;&lt;"/path?dummy=2785"&gt;&gt; = iolist_to_binary(uri(Req, #{host =&gt; &lt;&lt;&gt;&gt;})),
    &lt;&lt;"/path?dummy=2785"&gt;&gt; = iolist_to_binary(uri(Req, #{host =&gt; ""})),
    &lt;&lt;"/path?dummy=2785"&gt;&gt; = iolist_to_binary(uri(Req, #{host =&gt; [&lt;&lt;&gt;&gt;]})),
    &lt;&lt;"http://localhost:8080?dummy=2785"&gt;&gt; = iolist_to_binary(uri(Req, #{path =&gt; &lt;&lt;&gt;&gt;})),
    &lt;&lt;"http://localhost:8080?dummy=2785"&gt;&gt; = iolist_to_binary(uri(Req, #{path =&gt; ""})),
    &lt;&lt;"http://localhost:8080?dummy=2785"&gt;&gt; = iolist_to_binary(uri(Req, #{path =&gt; [&lt;&lt;&gt;&gt;]})),
    &lt;&lt;"http://localhost:8080/path"&gt;&gt; = iolist_to_binary(uri(Req, #{qs =&gt; &lt;&lt;&gt;&gt;})),
    &lt;&lt;"http://localhost:8080/path"&gt;&gt; = iolist_to_binary(uri(Req, #{qs =&gt; ""})),
    &lt;&lt;"http://localhost:8080/path"&gt;&gt; = iolist_to_binary(uri(Req, #{qs =&gt; [&lt;&lt;&gt;&gt;]})),
    &lt;&lt;"http://localhost:8080/path?dummy=2785"&gt;&gt; = iolist_to_binary(uri(Req, #{fragment =&gt; &lt;&lt;&gt;&gt;})),
    &lt;&lt;"http://localhost:8080/path?dummy=2785"&gt;&gt; = iolist_to_binary(uri(Req, #{fragment =&gt; ""})),
    &lt;&lt;"http://localhost:8080/path?dummy=2785"&gt;&gt; = iolist_to_binary(uri(Req, #{fragment =&gt; [&lt;&lt;&gt;&gt;]})),
    %% Port is integer() | undefined.
    {'EXIT', <em>} = (catch iolist_to_binary(uri(Req, #{port =&gt; &lt;&lt;&gt;&gt;}))),
    {'EXIT', </em>} = (catch iolist_to_binary(uri(Req, #{port =&gt; ""}))),
    {'EXIT', _} = (catch iolist_to_binary(uri(Req, #{port =&gt; [&lt;&lt;&gt;&gt;]}))),
    %% Update components.
    &lt;&lt;"https://localhost:8080/path?dummy=2785"&gt;&gt; = iolist_to_binary(uri(Req, #{scheme =&gt; "https"})),
    &lt;&lt;"http://example.org:8080/path?dummy=2785"&gt;&gt; = iolist_to_binary(uri(Req, #{host =&gt; "example.org"})),
    &lt;&lt;"http://localhost:123/path?dummy=2785"&gt;&gt; = iolist_to_binary(uri(Req, #{port =&gt; 123})),
    &lt;&lt;"http://localhost:8080/custom?dummy=2785"&gt;&gt; = iolist_to_binary(uri(Req, #{path =&gt; "/custom"})),
    &lt;&lt;"http://localhost:8080/path?smart=42"&gt;&gt; = iolist_to_binary(uri(Req, #{qs =&gt; "smart=42"})),
    &lt;&lt;"http://localhost:8080/path?dummy=2785#intro"&gt;&gt; = iolist_to_binary(uri(Req, #{fragment =&gt; "intro"})),
    %% Interesting combinations.
    &lt;&lt;"http://localhost/path?dummy=2785"&gt;&gt; = iolist_to_binary(uri(Req, #{port =&gt; 80})),
    &lt;&lt;"https://localhost/path?dummy=2785"&gt;&gt; = iolist_to_binary(uri(Req, #{scheme =&gt; "https", port =&gt; 443})),
    ok.
-endif.</p>
<p>-spec binding(atom(), req()) -&gt; any() | undefined.
- <code>cookie_name(&lt;&lt;$\s, Rest/binary&gt;&gt;)</code> - This is a specialized function to extract a cookie name
%% regardless of whether the name is valid or not. We skip
%% whitespace at the beginning and take whatever's left to
%% be the cookie name, up to the = sign.
- <code>has_body(#{has_body := HasBody})</code> - Request body.</p>
<p>-spec has_body(req()) -&gt; boolean().
- <code>body_length(#{body_length := Length})</code> - The length may not be known if HTTP/1.1 with a transfer-encoding;
%% or HTTP/2 with no content-length header. The length is always
%% known once the body has been completely read.
-spec body_length(req()) -&gt; undefined | non_neg_integer().
- <code>set_body_length(Req=#{headers := Headers}, BodyLength)</code> - infinity + 1000 = infinity.
        _ -&gt; Period + 1000
    end,
    Timeout = maps:get(timeout, Opts, DefaultTimeout),
    Ref = make_ref(),
    cast({read_body, self(), Ref, Length, Period}, Req),
    receive
        {request_body, Ref, nofin, Body} -&gt;
            {more, Body, Req};
        {request_body, Ref, fin, BodyLength, Body} -&gt;
            {ok, Body, set_body_length(Req, BodyLength)}
    after Timeout -&gt;
        exit(timeout)
    end.
- <code>read_part(Req)</code> - Multipart.</p>
<p>-spec read_part(Req)
    -&gt; {ok, cowboy:http_headers(), Req} | {done, Req}
    when Req::req().
- <code>read_part_body(Req)</code> - Reject multipart content containing duplicate headers.
            true = map_size(Headers) =:= length(Headers0),
            {ok, Headers, Req#{multipart =&gt; {Boundary, Rest}}};
        %% Ignore epilogue.
        {done, <em>} -&gt;
            {done, Req#{multipart =&gt; done}}
    catch </em>:_:Stacktrace -&gt;
        erlang:raise(exit, {request_error, {multipart, headers},
            'Malformed body; multipart expected.'
        }, Stacktrace)
    end.</p>
<p>-spec read_part_body(Req)
    -&gt; {ok, binary(), Req} | {more, binary(), Req}
    when Req::req().
- <code>stream_multipart(Req=#{multipart := {Boundary, Buffer}}, _, _)</code> - We crash when the data ends unexpectedly.
        {ok, &lt;&lt;&gt;&gt;, _} -&gt;
            exit({request_error, {multipart, Type},
                'Malformed body; multipart expected.'});
        {ok, Data, Req2} -&gt;
            {Data, Req2}
    end;
- <code>set_resp_cookie(Name, Value, Req, Opts)</code> - The cookie name cannot contain any of the following characters:
%%   =,;\s\t\r\n\013\014
%%
%% The cookie value cannot contain any of the following characters:
%%   ,; \t\r\n\013\014
-spec set_resp_cookie(binary(), iodata(), Req, cow_cookie:cookie_opts())
    -&gt; Req when Req::req().
- <code>set_resp_header(&lt;&lt;"set-cookie"&gt;&gt;, _, _)</code> - @todo We could add has_resp_cookie and unset_resp_cookie now.</p>
<p>-spec set_resp_header(binary(), iodata(), Req)
    -&gt; Req when Req::req().
- <code>delete_resp_header(_, Req)</code> - There are no resp headers so we have nothing to delete.
- <code>reply(Status, Headers, Body, Req)
        when Status =:= 204; Status =:= 304 -&gt;
    do_reply_ensure_no_body(Status, Headers, Body, Req);
reply(Status = &lt;&lt;"204",_/bits&gt;&gt;, Headers, Body, Req)</code> - 204 responses must not include content-length. 304 responses may
%% but only when set explicitly. (RFC7230 3.3.1, RFC7230 3.3.2)
%% Neither status code must include a response body. (RFC7230 3.3)
- <code>do_reply(Status, Headers, _, Req=#{method := &lt;&lt;"HEAD"&gt;&gt;})</code> - Don't send any body for HEAD responses. While the protocol code is
%% supposed to enforce this rule, we prefer to avoid copying too much
%% data around if we can avoid it.
- <code>stream_reply(Status, Headers=#{}, Req)
        when Status =:= 204; Status =:= 304 -&gt;
    reply(Status, Headers, &lt;&lt;&gt;&gt;, Req);
stream_reply(Status = &lt;&lt;"204",_/bits&gt;&gt;, Headers=#{}, Req)</code> - 204 and 304 responses must NOT send a body. We therefore
%% transform the call to a full response and expect the user
%% to NOT call stream_body/3 afterwards. (RFC7230 3.3)
- <code>stream_body(Msg, Req=#{pid := Pid})</code> - @todo Do we need a timeout?
- <code>push(_, _, #{has_sent_resp := _}, _)</code> - @todo Optimization: don't send anything at all for HTTP/1.0 and HTTP/1.1.
%% @todo Path, Headers, Opts, everything should be in proper binary,
%% or normalized when creating the Req object.
-spec push(iodata(), cowboy:http_headers(), req(), push_opts()) -&gt; ok.
- <code>cast(Msg, #{pid := Pid, streamid := StreamID})</code> - Stream handlers.</p>
<p>-spec cast(any(), req()) -&gt; ok.
- <code>response_headers(Headers0, Req)</code> - Internal.</p>
<p>%% @todo What about set-cookie headers set through set_resp_header or reply?
-spec response_headers(Headers, req()) -&gt; Headers when Headers::cowboy:http_headers().
- <code>kvlist_to_map(Fields, KvList)</code> - The set-cookie header is special; we can only send one cookie per header.
    %% We send the list of values for many cookies in one key of the map,
    %% and let the protocols deal with it directly.
    case maps:get(resp_cookies, Req, undefined) of
        undefined -&gt; Headers;
        RespCookies -&gt; Headers#{&lt;&lt;"set-cookie"&gt;&gt; =&gt; maps:values(RespCookies)}
    end.</p>
<p>%% Create map, convert keys to atoms and group duplicate keys into lists.
%% Keys that are not found in the user provided list are entirely skipped.
%% @todo Can probably be done directly while parsing.
- <code>filter([], Map, Errors)</code> - Loop through fields, if value is missing and no default,
%% record the error; else if value is missing and has a
%% default, set default; otherwise apply constraints. If
%% constraint fails, record the error.
%%
%% When there is an error at the end, crash.</p>
<p><strong>Dependencies</strong>: cowboy_constraints, cowboy_router, cowboy_clock, cowboy_stream, cowboy</p>
<hr />
<h3 id="cowboy_rest">cowboy_rest</h3>
<p><strong>File</strong>: <code>/Users/ddleon/.erlviz/cache/ninenines_cowboy/src/cowboy_rest.erl</code></p>
<p><strong>Behaviors</strong>: cowboy_sub_protocol</p>
<p><strong>Description</strong>:
Copyright (c) Loïc Hoguin <a href="&#109;&#97;&#105;&#108;&#116;&#111;&#58;&#101;&#115;&#115;&#101;&#110;&#64;&#110;&#105;&#110;&#101;&#110;&#105;&#110;&#101;&#115;&#46;&#101;&#117;">&#101;&#115;&#115;&#101;&#110;&#64;&#110;&#105;&#110;&#101;&#110;&#105;&#110;&#101;&#115;&#46;&#101;&#117;</a>
%% Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted, provided that the above
copyright notice and this permission notice appear in all copies.
%% THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF</p>
<p><strong>Exported Functions</strong>: upgrade/4, upgrade/5</p>
<p><strong>Functions</strong>:</p>
<ul>
<li><code>upgrade(Req, Env, Handler, HandlerState, _Opts)</code> - cowboy_rest takes no options.</li>
<li><code>known_methods(Req, State=#state{method=Method})</code> - known_methods/2 should return a list of binary methods.</li>
<li><code>allowed_methods(Req, State=#state{method=Method})</code> - allowed_methods/2 should return a list of binary methods.</li>
<li><code>is_authorized(Req, State)</code> - is_authorized/2 should return true or {false, WwwAuthenticateHeader}.</li>
<li><code>options(Req, State=#state{method= &lt;&lt;"OPTIONS"&gt;&gt;})</code> - If you need to add additional headers to the response at this point,
%% you should do it directly in the options/2 call using set_resp_headers.</li>
<li><code>content_types_provided(Req, State)</code> - content_types_provided/2 should return a list of content types and their
%% associated callback function as a tuple: {{Type, SubType, Params}, Fun}.
%% Type and SubType are the media type as binary. Params is a list of
%% Key/Value tuple, with Key and Value a binary. Fun is the name of the
%% callback that will be used to return the content of the response. It is
%% given as an atom.
%%
%% An example of such return value would be:
%%    {{&lt;&lt;"text"&gt;&gt;, &lt;&lt;"html"&gt;&gt;, []}, to_html}
%%
%% Note that it is also possible to return a binary content type that will
%% then be parsed by Cowboy. However note that while this may make your
%% resources a little more readable, this is a lot less efficient.
%%
%% An example of such return value would be:
%%    {&lt;&lt;"text/html"&gt;&gt;, to_html}</li>
<li><code>normalize_content_types(Normalized = {'*', _}, accept)</code> - Wildcard for content_types_accepted.</li>
<li><code>prioritize_mediatype({TypeA, SubTypeA, ParamsA}, {TypeB, SubTypeB, ParamsB})</code> - Same quality, check precedence in more details.
                prioritize_mediatype(MediaTypeA, MediaTypeB);
            ({_MediaTypeA, QualityA, _AcceptParamsA},
             {_MediaTypeB, QualityB, _AcceptParamsB}) -&gt;
                %% Just compare the quality.
                QualityA &gt; QualityB
        end, Accept).</li>
</ul>
<p>%% Media ranges can be overridden by more specific media ranges or
%% specific media types. If more than one media range applies to a given
%% type, the most specific reference has precedence.
%%
%% We always choose B over A when we can't decide between the two.
- <code>choose_media_type(Req, State, [])</code> - Ignoring the rare AcceptParams. Not sure what should be done about them.
- <code>match_media_type_params(Req, State, Accept,
        [Provided = {PMT = {TP, STP, Params_P0}, Fun}|Tail],
        MediaType = {{_TA, _STA, Params_A}, _QA, _APA})</code> - When we match against a wildcard, the media type is text
            %% and has a charset parameter, we call charsets_provided
            %% and check that the charset is provided. If the callback
            %% is not exported, we accept inconditionally but ignore
            %% the given charset so as to not send a wrong value back.
            case call(Req, State, charsets_provided) of
                no_call -&gt;
                    languages_provided(Req#{media_type =&gt; {TP, STP, Params_A0}},
                        State#state{content_type_a=Provided});
                {stop, Req2, State2} -&gt;
                    terminate(Req2, State2);
                {Switch, Req2, State2} when element(1, Switch) =:= switch_handler -&gt;
                    switch_handler(Switch, Req2, State2);
                {CP, Req2, State2} -&gt;
                    State3 = State2#state{charsets_p=CP},
                    case lists:member(Charset, CP) of
                        false -&gt;
                            match_media_type(Req2, State3, Accept, Tail, MediaType);
                        true -&gt;
                            languages_provided(Req2#{media_type =&gt; {TP, STP, Params_A}},
                                State3#state{content_type_a=Provided,
                                    charset_a=Charset})
                    end
            end;
        _ -&gt;
            languages_provided(Req#{media_type =&gt; {TP, STP, Params_A0}},
                State#state{content_type_a=Provided})
    end;
- <code>languages_provided(Req, State)</code> - When a charset was provided explicitly in both the charset header
            %% and the media types provided and the negotiation is successful,
            %% we keep the charset and don't call charsets_provided. This only
            %% applies to text media types, however.
            {Charset, Params_P} = case lists:keytake(&lt;&lt;"charset"&gt;&gt;, 1, Params_P0) of
                false -&gt; {undefined, Params_P0};
                {value, {_, Charset0}, Params_P1} -&gt; {Charset0, Params_P1}
            end,
            languages_provided(Req#{media_type =&gt; {TP, STP, Params_P}},
                State#state{content_type_a={{TP, STP, Params_P}, Fun},
                    charset_a=Charset});
        true -&gt;
            languages_provided(Req#{media_type =&gt; PMT},
                State#state{content_type_a=Provided});
        false -&gt;
            match_media_type(Req, State, Accept, Tail, MediaType)
    end.</p>
<p>%% languages_provided should return a list of binary values indicating
%% which languages are accepted by the resource.
%%
%% @todo I suppose we should also ask the resource if it wants to
%% set a language itself or if it wants it to be automatically chosen.
- <code>prioritize_languages(AcceptLanguages)</code> - A language-range matches a language-tag if it exactly equals the tag,
%% or if it exactly equals a prefix of the tag such that the first tag
%% character following the prefix is "-". The special range "<em>", if
%% present in the Accept-Language field, matches every tag not matched
%% by any other range present in the Accept-Language field.
%%
%% @todo The last sentence probably means we should always put '</em>'
%% at the end of the list.
- <code>charsets_provided(Req, State=#state{charset_a=Charset})
        when Charset =/= undefined -&gt;
    set_content_type(Req, State);
%% If charsets_p is defined, use it instead of calling charsets_provided
%% again. We also call this clause during normal execution to avoid
%% duplicating code.
charsets_provided(Req, State=#state{charsets_p=[]})</code> - charsets_provided should return a list of binary values indicating
%% which charsets are accepted by the resource.
%%
%% A charset may have been selected while negotiating the accept header.
%% There's no need to select one again.
- <code>choose_charset(Req, State, [{_, 0}|Tail])</code> - A q-value of 0 means not acceptable.
- <code>encodings_provided(Req, State)</code> - @todo Match for identity as we provide nothing else for now.
%% @todo Don't forget to set the Content-Encoding header when we reply a body
%% and the found encoding is something other than identity.
- <code>variances(Req, State=#state{content_types_p=CTP,
        languages_p=LP, charsets_p=CP})</code> - variances/2 should return a list of headers that will be added
%% to the Vary response header. The Accept, Accept-Language,
%% Accept-Charset and Accept-Encoding headers do not need to be
%% specified.
%%
%% @todo Do Accept-Encoding too when we handle it.
%% @todo Does the order matter?
- <code>if_match_must_not_exist(Req, State)</code> - Strong Etag comparison: weak Etag never matches.
        {{weak, <em>}, Req2, State2} -&gt;
            precondition_failed(Req2, State2);
        {Etag, Req2, State2} -&gt;
            case lists:member(Etag, EtagsList) of
                true -&gt; if_none_match_exists(Req2, State2);
                %% Etag may be <code>undefined' which cannot be a member.
                false -&gt; precondition_failed(Req2, State2)
            end
    catch Class:Reason:Stacktrace -&gt;
        error_terminate(Req, State, Class, Reason, Stacktrace)
    end.
-</code>if_unmodified_since(Req, State, IfUnmodifiedSince)<code>- If LastModified is the atom 'no_call', we continue.
-</code>is_weak_match(</em>, [])<code>- Weak Etag comparison: only check the opaque tag.
-</code>moved_permanently(Req, State, OnFalse)<code>- moved_permanently/2 should return either false or {true, Location}
%% with Location the full new URI of the resource.
-</code>moved_temporarily(Req, State)<code>- moved_temporarily/2 should return either false or {true, Location}
%% with Location the full new URI of the resource.
-</code>delete_resource(Req, State)<code>- delete_resource/2 should start deleting the resource and return.
-</code>delete_completed(Req, State)<code>- delete_completed/2 indicates whether the resource has been deleted yet.
-</code>accept_resource(Req, State)<code>- content_types_accepted should return a list of media types and their
%% associated callback functions in the same format as content_types_provided.
%%
%% The callback will then be called and is expected to process the content
%% pushed to the resource in the request body.
%%
%% content_types_accepted SHOULD return a different list
%% for each HTTP method.
-</code>choose_content_type(Req, State, {Type, SubType, Param},
        [{{Type, SubType, AcceptedParam}, Fun}|<em>Tail])
        when AcceptedParam =:= '*'; AcceptedParam =:= Param -&gt;
    process_content_type(Req, State, Fun);
choose_content_type(Req, State, ContentType, [_Any|Tail])<code>- The special parameter '*' will always match any kind of content type
%% parameters.
%% Note that because it will always match, it should be the last of the
%% list for specific content type, otherwise it'll shadow the ones following.
-</code>maybe_created(Req, State=#state{method= &lt;&lt;"PUT"&gt;&gt;})<code>- If PUT was used then the resource has been created at the current URL.
%% Otherwise, if a location header has been set then the resource has been
%% created at a new URL. If not, send a 200 or 204 as expected from a
%% POST or PATCH request.
-</code>set_resp_body_etag(Req, State)<code>- Set the Etag header if any for the response provided.
-</code>set_resp_body_last_modified(Req, State)<code>- Set the Last-Modified header if any for the response provided.
-</code>set_resp_body_expires(Req, State)<code>- Set the Expires header if any for the response provided.
-</code>if_range(Req, State)<code>- Strong etag comparison is an exact match with the generate_etag result.
        Etag={strong, _} -&gt;
            range(Req, State);
        %% We cannot do a strong date comparison because we have
        %% no way of knowing whether the representation changed
        %% twice during the second covered by the presented
        %% validator. (RFC7232 2.2.2)
        _ -&gt;
            set_resp_body(Req, State)
    catch _:_ -&gt;
        set_resp_body(Req, State)
    end;
-</code>range(Req, State=#state{ranges_a=[]})<code>- @todo This can probably be moved to if_range directly.
-</code>choose_range(Req, State=#state{ranges_a=RangesAccepted}, Range={RangeUnit, </em>})<code>- @todo Maybe change parse_header to return &lt;&lt;"bytes"&gt;&gt; in 3.0.
        {bytes, BytesRange} -&gt;
            choose_range(Req, State, {&lt;&lt;"bytes"&gt;&gt;, BytesRange});
        Range -&gt;
            choose_range(Req, State, Range)
    catch _:_ -&gt;
        %% We send a 416 response back when we can't parse the
        %% range header at all. I'm not sure this is the right
        %% way to go but at least this can help clients identify
        %% what went wrong when their range requests never work.
        range_not_satisfiable(Req, State, undefined)
    end.
-</code>range_satisfiable(Req, State, Callback)<code>- We pass the selected range onward in the Req.
            range_satisfiable(Req#{range =&gt; Range}, State, Callback);
        false -&gt;
            set_resp_body(Req, State)
    end.
-</code>set_ranged_body(Req=#{range := {&lt;&lt;"bytes"&gt;&gt;, <em>}}, State, auto)<code>- When the callback selected is 'auto' and the range unit
%% is bytes, we call the normal provide callback and split
%% the content automatically.
-</code>set_ranged_body_auto(Req=#{range := {</em>, Ranges}}, State, Body)<code>- We might also want to have some checks about range order,
%% number of ranges, and perhaps also join ranges that are
%% too close into one contiguous range. Some of these can
%% be done before calling the ProvideCallback.
-</code>set_ranged_body_callback(Req, State=#state{handler=Handler}, Callback)<code>- Sendfile with open-ended range.
        {{0, infinity}, {sendfile, 0, 12, "t"}, {{0, 11, 12}, {sendfile, 0, 12, "t"}}},
        {{6, infinity}, {sendfile, 0, 12, "t"}, {{6, 11, 12}, {sendfile, 6, 6, "t"}}},
        {{11, infinity}, {sendfile, 0, 12, "t"}, {{11, 11, 12}, {sendfile, 11, 1, "t"}}},
        %% Sendfile with open-ended range. Sendfile tuple has an offset originally.
        {{0, infinity}, {sendfile, 3, 12, "t"}, {{0, 11, 12}, {sendfile, 3, 12, "t"}}},
        {{6, infinity}, {sendfile, 3, 12, "t"}, {{6, 11, 12}, {sendfile, 9, 6, "t"}}},
        {{11, infinity}, {sendfile, 3, 12, "t"}, {{11, 11, 12}, {sendfile, 14, 1, "t"}}},
        %% Sendfile with a specific range.
        {{0, 11}, {sendfile, 0, 12, "t"}, {{0, 11, 12}, {sendfile, 0, 12, "t"}}},
        {{6, 11}, {sendfile, 0, 12, "t"}, {{6, 11, 12}, {sendfile, 6, 6, "t"}}},
        {{11, 11}, {sendfile, 0, 12, "t"}, {{11, 11, 12}, {sendfile, 11, 1, "t"}}},
        {{1, 10}, {sendfile, 0, 12, "t"}, {{1, 10, 12}, {sendfile, 1, 10, "t"}}},
        %% Sendfile with a specific range. Sendfile tuple has an offset originally.
        {{0, 11}, {sendfile, 3, 12, "t"}, {{0, 11, 12}, {sendfile, 3, 12, "t"}}},
        {{6, 11}, {sendfile, 3, 12, "t"}, {{6, 11, 12}, {sendfile, 9, 6, "t"}}},
        {{11, 11}, {sendfile, 3, 12, "t"}, {{11, 11, 12}, {sendfile, 14, 1, "t"}}},
        {{1, 10}, {sendfile, 3, 12, "t"}, {{1, 10, 12}, {sendfile, 4, 10, "t"}}},
        %% Sendfile with negative range.
        {-12, {sendfile, 0, 12, "t"}, {{0, 11, 12}, {sendfile, 0, 12, "t"}}},
        {-6, {sendfile, 0, 12, "t"}, {{6, 11, 12}, {sendfile, 6, 6, "t"}}},
        {-1, {sendfile, 0, 12, "t"}, {{11, 11, 12}, {sendfile, 11, 1, "t"}}},
        %% Sendfile with negative range. Sendfile tuple has an offset originally.
        {-12, {sendfile, 3, 12, "t"}, {{0, 11, 12}, {sendfile, 3, 12, "t"}}},
        {-6, {sendfile, 3, 12, "t"}, {{6, 11, 12}, {sendfile, 9, 6, "t"}}},
        {-1, {sendfile, 3, 12, "t"}, {{11, 11, 12}, {sendfile, 14, 1, "t"}}},
        %% Iodata with open-ended range.
        {{0, infinity}, &lt;&lt;"Hello world!"&gt;&gt;, {{0, 11, 12}, &lt;&lt;"Hello world!"&gt;&gt;}},
        {{6, infinity}, &lt;&lt;"Hello world!"&gt;&gt;, {{6, 11, 12}, &lt;&lt;"world!"&gt;&gt;}},
        {{11, infinity}, &lt;&lt;"Hello world!"&gt;&gt;, {{11, 11, 12}, &lt;&lt;"!"&gt;&gt;}},
        %% Iodata with a specific range. The resulting data is
        %% wrapped in a list because of how cow_iolists:split/2 works.
        {{0, 11}, &lt;&lt;"Hello world!"&gt;&gt;, {{0, 11, 12}, [&lt;&lt;"Hello world!"&gt;&gt;]}},
        {{6, 11}, &lt;&lt;"Hello world!"&gt;&gt;, {{6, 11, 12}, [&lt;&lt;"world!"&gt;&gt;]}},
        {{11, 11}, &lt;&lt;"Hello world!"&gt;&gt;, {{11, 11, 12}, [&lt;&lt;"!"&gt;&gt;]}},
        {{1, 10}, &lt;&lt;"Hello world!"&gt;&gt;, {{1, 10, 12}, [&lt;&lt;"ello world"&gt;&gt;]}},
        %% Iodata with negative range.
        {-12, &lt;&lt;"Hello world!"&gt;&gt;, {{0, 11, 12}, &lt;&lt;"Hello world!"&gt;&gt;}},
        {-6, &lt;&lt;"Hello world!"&gt;&gt;, {{6, 11, 12}, &lt;&lt;"world!"&gt;&gt;}},
        {-1, &lt;&lt;"Hello world!"&gt;&gt;, {{11, 11, 12}, &lt;&lt;"!"&gt;&gt;}}
    ],
    [{iolist_to_binary(io_lib:format("range ~p data ~p", [VR, VD])),
        fun() -&gt; R = ranged_partition(VR, VD) end} || {VR, VD, R} &lt;- Tests].
-endif.
-</code>set_one_ranged_body(Req0, State, OneRange)<code>- When we receive a single range, we send it directly.
        {[OneRange], Req2, State2} -&gt;
            set_one_ranged_body(Req2, State2, OneRange);
        %% When we receive multiple ranges we have to send them as multipart/byteranges.
        %% This also applies to non-bytes units. (RFC7233 A) If users don't want to use
        %% this for non-bytes units they can always return a single range with a binary
        %% content-range information.
        {Ranges, Req2, State2} when length(Ranges) &gt; 1 -&gt;
            %% We have to check whether there are sendfile tuples in the
            %% ranges to be sent. If there are we must use stream_reply.
            HasSendfile = [] =/= [true || {_, {sendfile, _, _, _}} &lt;- Ranges],
            case HasSendfile of
                true -&gt; send_multipart_ranged_body(Req2, State2, Ranges);
                false -&gt; set_multipart_ranged_body(Req2, State2, Ranges)
            end
    end catch Class:{case_clause, no_call}:Stacktrace -&gt;
        error_terminate(Req, State, Class, {error, {missing_callback, {Handler, Callback, 2}},
            'A callback specified in ranges_provided/2 is not exported.'},
            Stacktrace)
    end.
-</code>send_multipart_ranged_body(Req, State, [FirstRange|MoreRanges])<code>- Similar to set_multipart_ranged_body except we have to stream
%% the data because the parts contain sendfile tuples.
-</code>range_not_satisfiable(Req, State, undefined)<code>- We send the content-range header when we can on error.
-</code>set_resp_body(Req, State=#state{handler=Handler, content_type_a={_, Callback}})<code>- Set the response headers and call the callback found using
%% content_types_provided/2 to obtain the request body and add
%% it to the response.
-</code>set_resp_etag(Req, State)<code>- Response utility functions.
-</code>generate_etag(Req, State=#state{etag=Etag})<code>- We allow the callback to return 'undefined'
        %% to allow conditionally generating etags. We
        %% handle 'undefined' the same as if the function
        %% was not exported.
        {undefined, Req2, State2} -&gt;
            {undefined, Req2, State2#state{etag=no_call}};
        {Etag, Req2, State2} when is_binary(Etag) -&gt;
            Etag2 = cow_http_hd:parse_etag(Etag),
            {Etag2, Req2, State2#state{etag=Etag2}};
        {Etag, Req2, State2} -&gt;
            {Etag, Req2, State2#state{etag=Etag}}
    end;
-</code>expect(Req, State, Callback, Expected, OnTrue, OnFalse)<code>- REST primitives.
-</code>switch_handler({switch_handler, Mod}, Req, #state{handler_state=HandlerState})` - We remove the content-type header when there is no body,
    %% except when the status code is 200 because it might have
    %% been intended (for example sending an empty file).
    Req = case cowboy_req:has_resp_body(Req0) of
        true when StatusCode =:= 200 -&gt; Req0;
        true -&gt; Req0;
        false -&gt; cowboy_req:delete_resp_header(&lt;&lt;"content-type"&gt;&gt;, Req0)
    end,
    terminate(cowboy_req:reply(StatusCode, Req), State).</p>
<p><strong>Dependencies</strong>: cowboy_clock, cowboy_req, cowboy_middleware, cowboy_handler</p>
<hr />
<h3 id="cowboy_router">cowboy_router</h3>
<p><strong>File</strong>: <code>/Users/ddleon/.erlviz/cache/ninenines_cowboy/src/cowboy_router.erl</code></p>
<p><strong>Behaviors</strong>: cowboy_middleware</p>
<p><strong>Description</strong>:
Copyright (c) Loïc Hoguin <a href="&#109;&#97;&#105;&#108;&#116;&#111;&#58;&#101;&#115;&#115;&#101;&#110;&#64;&#110;&#105;&#110;&#101;&#110;&#105;&#110;&#101;&#115;&#46;&#101;&#117;">&#101;&#115;&#115;&#101;&#110;&#64;&#110;&#105;&#110;&#101;&#110;&#105;&#110;&#101;&#115;&#46;&#101;&#117;</a>
%% Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted, provided that the above
copyright notice and this permission notice appear in all copies.
%% THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF</p>
<p><strong>Exported Functions</strong>: compile/1, execute/2</p>
<p><strong>Functions</strong>:</p>
<ul>
<li><code>compile(Routes)</code> - Copyright (c) Loïc Hoguin <a href="&#109;&#97;&#105;&#108;&#116;&#111;&#58;&#101;&#115;&#115;&#101;&#110;&#64;&#110;&#105;&#110;&#101;&#110;&#105;&#110;&#101;&#115;&#46;&#101;&#117;">&#101;&#115;&#115;&#101;&#110;&#64;&#110;&#105;&#110;&#101;&#110;&#105;&#110;&#101;&#115;&#46;&#101;&#117;</a>
%%
%% Permission to use, copy, modify, and/or distribute this software for any
%% purpose with or without fee is hereby granted, provided that the above
%% copyright notice and this permission notice appear in all copies.
%%
%% THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
%% WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
%% MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
%% ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
%% WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
%% ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
%% OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.</li>
</ul>
<p>%% Routing middleware.
%%
%% Resolve the handler to be used for the request based on the
%% routing information found in the <em>dispatch</em> environment value.
%% When found, the handler module and associated data are added to
%% the environment as the <em>handler</em> and <em>handler_opts</em> values
%% respectively.
%%
%% If the route cannot be found, processing stops with either
%% a 400 or a 404 reply.
-module(cowboy_router).
-behaviour(cowboy_middleware).</p>
<p>-export([compile/1]).
-export([execute/2]).</p>
<p>-type bindings() :: #{atom() =&gt; any()}.
-type tokens() :: [binary()].
-export_type([bindings/0]).
-export_type([tokens/0]).</p>
<p>-type route_match() :: '_' | iodata().
-type route_path() :: {Path::route_match(), Handler::module(), Opts::any()}
    | {Path::route_match(), cowboy:fields(), Handler::module(), Opts::any()}.
-type route_rule() :: {Host::route_match(), Paths::[route_path()]}
    | {Host::route_match(), cowboy:fields(), Paths::[route_path()]}.
-type routes() :: [route_rule()].
-export_type([routes/0]).</p>
<p>-type dispatch_match() :: '<em>' | &lt;&lt;</em>:8&gt;&gt; | [binary() | '_' | '...' | atom()].
-type dispatch_path() :: {dispatch_match(), cowboy:fields(), module(), any()}.
-type dispatch_rule() :: {Host::dispatch_match(), cowboy:fields(), Paths::[dispatch_path()]}.
-opaque dispatch_rules() :: [dispatch_rule()].
-export_type([dispatch_rules/0]).</p>
<p>-spec compile(routes()) -&gt; dispatch_rules().
- <code>compile_rules(&lt;&lt; $], _/bits &gt;&gt;, _, _, _, _)</code> - Missing an open bracket.
- <code>compile_binding(&lt;&lt;&gt;&gt;, _, &lt;&lt;&gt;&gt;)</code> - Everything past $: until the segment separator ($. for hosts,
%% $/ for paths) or $[ or $] or end of binary is the binding name.
- <code>compile_brackets_split(&lt;&lt; C, Rest/bits &gt;&gt;, Acc, N) when C =:= $[ -&gt;
    compile_brackets_split(Rest, &lt;&lt; Acc/binary, C &gt;&gt;, N + 1);
compile_brackets_split(&lt;&lt; C, Rest/bits &gt;&gt;, Acc, N) when C =:= $], N &gt; 0 -&gt;
    compile_brackets_split(Rest, &lt;&lt; Acc/binary, C &gt;&gt;, N - 1);
%% That's the right one.
compile_brackets_split(&lt;&lt; $], Rest/bits &gt;&gt;, Acc, 0)</code> - Make sure we don't confuse the closing bracket we're looking for.
- <code>match([{'_', [], PathMatchs}|_Tail], _, Path)</code> - If the host is '<em>' then there can be no constraints.
- <code>match_path([{'_', [], Handler, Opts}|_Tail], HostInfo, _, Bindings)</code> - If the path is '</em>' then there can be no constraints.
- <code>split_path(&lt;&lt; $/, Path/bits &gt;&gt;)</code> - Following RFC2396, this function may return path segments containing any
%% character, including <em>/</em> if, and only if, a <em>/</em> was escaped
%% and part of a path segment.
-spec split_path(binary()) -&gt; tokens() | badrequest.
- <code>list_match(_List, _Match, _Binds)</code> - Values don't match, stop.
- <code>compile_test_()</code> - Tests.</p>
<p>-ifdef(TEST).
- <code>split_host_test_()</code> - Match any host and path.
        {[{'<em>', [{'</em>', h, o}]}],
            [{'<em>', [], [{'</em>', [], h, o}]}]},
        {[{"cowboy.example.org",
                [{"/", ha, oa}, {"/path/to/resource", hb, ob}]}],
            [{[&lt;&lt;"org"&gt;&gt;, &lt;&lt;"example"&gt;&gt;, &lt;&lt;"cowboy"&gt;&gt;], [], [
                {[], [], ha, oa},
                {[&lt;&lt;"path"&gt;&gt;, &lt;&lt;"to"&gt;&gt;, &lt;&lt;"resource"&gt;&gt;], [], hb, ob}]}]},
        {[{'<em>', [{"/path/to/resource/", h, o}]}],
            [{'</em>', [], [{[&lt;&lt;"path"&gt;&gt;, &lt;&lt;"to"&gt;&gt;, &lt;&lt;"resource"&gt;&gt;], [], h, o}]}]},
        % Cyrillic from a latin1 encoded file.
        {[{'<em>', [{[47,208,191,209,131,209,130,209,140,47,208,186,47,209,128,
                208,181,209,129,209,131,209,128,209,129,209,131,47], h, o}]}],
            [{'</em>', [], [{[&lt;&lt;208,191,209,131,209,130,209,140&gt;&gt;, &lt;&lt;208,186&gt;&gt;,
                &lt;&lt;209,128,208,181,209,129,209,131,209,128,209,129,209,131&gt;&gt;],
                [], h, o}]}]},
        {[{"cowboy.example.org.", [{'<em>', h, o}]}],
            [{[&lt;&lt;"org"&gt;&gt;, &lt;&lt;"example"&gt;&gt;, &lt;&lt;"cowboy"&gt;&gt;], [], [{'</em>', [], h, o}]}]},
        {[{".cowboy.example.org", [{'<em>', h, o}]}],
            [{[&lt;&lt;"org"&gt;&gt;, &lt;&lt;"example"&gt;&gt;, &lt;&lt;"cowboy"&gt;&gt;], [], [{'</em>', [], h, o}]}]},
        % Cyrillic from a latin1 encoded file.
        {[{[208,189,208,181,208,186,208,184,208,185,46,209,129,208,176,
                208,185,209,130,46,209,128,209,132,46], [{'<em>', h, o}]}],
            [{[&lt;&lt;209,128,209,132&gt;&gt;, &lt;&lt;209,129,208,176,208,185,209,130&gt;&gt;,
                &lt;&lt;208,189,208,181,208,186,208,184,208,185&gt;&gt;],
                [], [{'</em>', [], h, o}]}]},
        {[{":subdomain.example.org", [{"/hats/:name/prices", h, o}]}],
            [{[&lt;&lt;"org"&gt;&gt;, &lt;&lt;"example"&gt;&gt;, subdomain], [], [
                {[&lt;&lt;"hats"&gt;&gt;, name, &lt;&lt;"prices"&gt;&gt;], [], h, o}]}]},
        {[{"ninenines.:<em>", [{"/hats/:</em>", h, o}]}],
            [{['<em>', &lt;&lt;"ninenines"&gt;&gt;], [], [{[&lt;&lt;"hats"&gt;&gt;, '</em>'], [], h, o}]}]},
        {[{"[www.]ninenines.eu",
            [{"/horses", h, o}, {"/hats/[page/:number]", h, o}]}], [
                {[&lt;&lt;"eu"&gt;&gt;, &lt;&lt;"ninenines"&gt;&gt;], [], [
                    {[&lt;&lt;"horses"&gt;&gt;], [], h, o},
                    {[&lt;&lt;"hats"&gt;&gt;], [], h, o},
                    {[&lt;&lt;"hats"&gt;&gt;, &lt;&lt;"page"&gt;&gt;, number], [], h, o}]},
                {[&lt;&lt;"eu"&gt;&gt;, &lt;&lt;"ninenines"&gt;&gt;, &lt;&lt;"www"&gt;&gt;], [], [
                    {[&lt;&lt;"horses"&gt;&gt;], [], h, o},
                    {[&lt;&lt;"hats"&gt;&gt;], [], h, o},
                    {[&lt;&lt;"hats"&gt;&gt;, &lt;&lt;"page"&gt;&gt;, number], [], h, o}]}]},
        {[{'<em>', [{"/hats/:page/:number", h, o}]}], [{'</em>', [], [
            {[&lt;&lt;"hats"&gt;&gt;, page, number], [], h, o}]}]},
        {[{'<em>', [{"/hats/[page/[:number]]", h, o}]}], [{'</em>', [], [
            {[&lt;&lt;"hats"&gt;&gt;], [], h, o},
            {[&lt;&lt;"hats"&gt;&gt;, &lt;&lt;"page"&gt;&gt;], [], h, o},
            {[&lt;&lt;"hats"&gt;&gt;, &lt;&lt;"page"&gt;&gt;, number], [], h, o}]}]},
        {[{"[...]ninenines.eu", [{"/hats/[...]", h, o}]}],
            [{[&lt;&lt;"eu"&gt;&gt;, &lt;&lt;"ninenines"&gt;&gt;, '...'], [], [
                {[&lt;&lt;"hats"&gt;&gt;, '...'], [], h, o}]}]},
        %% Path segment containing a colon.
        {[{'<em>', [{"/foo/bar:blah", h, o}]}], [{'</em>', [], [
            {[&lt;&lt;"foo"&gt;&gt;, &lt;&lt;"bar:blah"&gt;&gt;], [], h, o}]}]}
    ],
    [{lists:flatten(io_lib:format("~p", [Rt])),
        fun() -&gt; Rs = compile(Rt) end} || {Rt, Rs} &lt;- Tests].</p>
<p><strong>Dependencies</strong>: cowboy_constraints, cowboy_req, cowboy_bstr, cowboy_middleware, cowboy</p>
<hr />
<h3 id="cowboy_static">cowboy_static</h3>
<p><strong>File</strong>: <code>/Users/ddleon/.erlviz/cache/ninenines_cowboy/src/cowboy_static.erl</code></p>
<p><strong>Description</strong>:
Copyright (c) Loïc Hoguin <a href="&#109;&#97;&#105;&#108;&#116;&#111;&#58;&#101;&#115;&#115;&#101;&#110;&#64;&#110;&#105;&#110;&#101;&#110;&#105;&#110;&#101;&#115;&#46;&#101;&#117;">&#101;&#115;&#115;&#101;&#110;&#64;&#110;&#105;&#110;&#101;&#110;&#105;&#110;&#101;&#115;&#46;&#101;&#117;</a>
Copyright (c) Magnus Klaar <a href="&#109;&#97;&#105;&#108;&#116;&#111;&#58;&#109;&#97;&#103;&#110;&#117;&#115;&#46;&#107;&#108;&#97;&#97;&#114;&#64;&#103;&#109;&#97;&#105;&#108;&#46;&#99;&#111;&#109;">&#109;&#97;&#103;&#110;&#117;&#115;&#46;&#107;&#108;&#97;&#97;&#114;&#64;&#103;&#109;&#97;&#105;&#108;&#46;&#99;&#111;&#109;</a>
%% Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted, provided that the above
copyright notice and this permission notice appear in all copies.
%% THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN</p>
<p><strong>Exported Functions</strong>: init/2, malformed_request/2, forbidden/2, content_types_provided/2, charsets_provided/2, ranges_provided/2, resource_exists/2, last_modified/2, generate_etag/2, get_file/2</p>
<p><strong>Functions</strong>:</p>
<ul>
<li><code>init(Req, {Name, Path})</code> - Copyright (c) Loïc Hoguin <a href="&#109;&#97;&#105;&#108;&#116;&#111;&#58;&#101;&#115;&#115;&#101;&#110;&#64;&#110;&#105;&#110;&#101;&#110;&#105;&#110;&#101;&#115;&#46;&#101;&#117;">&#101;&#115;&#115;&#101;&#110;&#64;&#110;&#105;&#110;&#101;&#110;&#105;&#110;&#101;&#115;&#46;&#101;&#117;</a>
%% Copyright (c) Magnus Klaar <a href="&#109;&#97;&#105;&#108;&#116;&#111;&#58;&#109;&#97;&#103;&#110;&#117;&#115;&#46;&#107;&#108;&#97;&#97;&#114;&#64;&#103;&#109;&#97;&#105;&#108;&#46;&#99;&#111;&#109;">&#109;&#97;&#103;&#110;&#117;&#115;&#46;&#107;&#108;&#97;&#97;&#114;&#64;&#103;&#109;&#97;&#105;&#108;&#46;&#99;&#111;&#109;</a>
%%
%% Permission to use, copy, modify, and/or distribute this software for any
%% purpose with or without fee is hereby granted, provided that the above
%% copyright notice and this permission notice appear in all copies.
%%
%% THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
%% WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
%% MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
%% ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
%% WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
%% ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
%% OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.</li>
</ul>
<p>-module(cowboy_static).</p>
<p>-export([init/2]).
-export([malformed_request/2]).
-export([forbidden/2]).
-export([content_types_provided/2]).
-export([charsets_provided/2]).
-export([ranges_provided/2]).
-export([resource_exists/2]).
-export([last_modified/2]).
-export([generate_etag/2]).
-export([get_file/2]).</p>
<p>-type extra_charset() :: {charset, module(), function()} | {charset, binary()}.
-type extra_etag() :: {etag, module(), function()} | {etag, false}.
-type extra_mimetypes() :: {mimetypes, module(), function()}
    | {mimetypes, binary() | {binary(), binary(), '*' | [{binary(), binary()}]}}.
-type extra() :: [extra_charset() | extra_etag() | extra_mimetypes()].
-type opts() :: {file | dir, string() | binary()}
    | {file | dir, string() | binary(), extra()}
    | {priv_file | priv_dir, atom(), string() | binary()}
    | {priv_file | priv_dir, atom(), string() | binary(), extra()}.
-export_type([opts/0]).</p>
<p>-include_lib("kernel/include/file.hrl").</p>
<p>-type state() :: {binary(), {direct | archive, #file_info{}}
    | {error, atom()}, extra()}.</p>
<p>%% Resolve the file that will be sent and get its file information.
%% If the handler is configured to manage a directory, check that the
%% requested file is inside the configured directory.</p>
<p>-spec init(Req, opts()) -&gt; {cowboy_rest, Req, error | state()} when Req::cowboy_req:req().
- <code>how_to_access_app_priv1(Dir)</code> - If the priv directory is not a directory, it must be
    %% inside an Erlang application .ez archive. We call
    %% how_to_access_app_priv1() to find the corresponding archive.
    case filelib:is_dir(PrivDir) of
        true  -&gt; direct;
        false -&gt; how_to_access_app_priv1(PrivDir)
    end.
- <code>absname(Path) when is_list(Path)</code> - We go "up" by one path component at a time and look for a
    %% regular file.
    Archive = filename:dirname(Dir),
    case Archive of
        Dir -&gt;
            %% filename:dirname() returned its argument:
            %% we reach the root directory. We found no
            %% archive so we return 'direct': the given priv
            %% directory doesn't exist.
            direct;
        _ -&gt;
            case filelib:is_regular(Archive) of
                true  -&gt; {archive, Archive};
                false -&gt; how_to_access_app_priv1(Archive)
            end
    end.
- <code>validate_reserved([])</code> - When dir/priv_dir are used and there is no path_info
        %% this is a configuration error and we abort immediately.
        undefined -&gt;
            {ok, cowboy_req:reply(500, Req), error};
        PathInfo -&gt;
            case validate_reserved(PathInfo) of
                error -&gt;
                    {cowboy_rest, Req, error};
                ok -&gt;
                    Filepath = filename:join([Dir|PathInfo]),
                    Len = byte_size(Dir),
                    case fullpath(Filepath) of
                        &lt;&lt; Dir:Len/binary, $/, _/binary &gt;&gt; -&gt;
                            init_info(Req, Filepath, HowToAccess, Extra);
                        &lt;&lt; Dir:Len/binary &gt;&gt; -&gt;
                            init_info(Req, Filepath, HowToAccess, Extra);
                        _ -&gt;
                            {cowboy_rest, Req, error}
                    end
            end
    end.
- <code>validate_reserved1(&lt;&lt;&gt;&gt;)</code> - We always reject forward slash, backward slash and NUL as
%% those have special meanings across the supported platforms.
%% We could support the backward slash on some platforms but
%% for the sake of consistency and simplicity we don't.
- <code>fix_archived_file_info(ArchiveInfo, ContainedFileInfo)</code> - The Erlang application archive is fine.
            %% Now check if the requested file is in that
            %% archive. We also need the file_info to merge
            %% them with the archive's one.
            PathS = binary_to_list(Path),
            case erl_prim_loader:read_file_info(PathS) of
                {ok, ContainedFileInfo} -&gt;
                    Info = fix_archived_file_info(
                        ArchiveInfo,
                        ContainedFileInfo),
                    {archive, Info};
                error -&gt;
                    {error, enoent}
            end;
        Error -&gt;
            Error
    end.
- <code>fullpath_test_()</code> - We merge the archive and content #file_info because we are
    %% interested by the timestamps of the archive, but the type and
    %% size of the contained file/directory.
    %%
    %% We reset the access to 'read', because we won't rewrite the
    %% archive.
    ArchiveInfo#file_info{
        size = ContainedFileInfo#file_info.size,
        type = ContainedFileInfo#file_info.type,
        access = read
    }.</p>
<p>-ifdef(TEST).
- <code>malformed_request(Req, State)</code> - Reject requests that tried to access a file outside
%% the target directory, or used reserved characters.</p>
<p>-spec malformed_request(Req, State)
    -&gt; {boolean(), Req, State}.
- <code>forbidden(Req, State={_, {_, #file_info{type=directory}}, _})</code> - Directories, files that can't be accessed at all and
%% files with no read flag are forbidden.</p>
<p>-spec forbidden(Req, State)
    -&gt; {boolean(), Req, State}
    when State::state().
- <code>content_types_provided(Req, State={Path, _, Extra}) when is_list(Extra)</code> - Detect the mimetype of the file.</p>
<p>-spec content_types_provided(Req, State)
    -&gt; {[{binary() | {binary(), binary(), '*' | [{binary(), binary()}]}, get_file}], Req, State}
    when State::state().
- <code>charsets_provided(Req, State={Path, _, Extra})</code> - Detect the charset of the file.</p>
<p>-spec charsets_provided(Req, State)
    -&gt; {[binary()], Req, State} | no_call
    when State::state().
- <code>ranges_provided(Req, State)</code> - We simulate the callback not being exported.
        false -&gt;
            no_call;
        {charset, Module, Function} -&gt;
            {[Module:Function(Path)], Req, State};
        {charset, Charset} when is_binary(Charset) -&gt;
            {[Charset], Req, State}
    end.</p>
<p>%% Enable support for range requests.</p>
<p>-spec ranges_provided(Req, State)
    -&gt; {[{binary(), auto}], Req, State}
    when State::state().
- <code>resource_exists(Req, State={_, {_, #file_info{type=regular}}, _})</code> - Assume the resource doesn't exist if it's not a regular file.</p>
<p>-spec resource_exists(Req, State)
    -&gt; {boolean(), Req, State}
    when State::state().
- <code>generate_etag(Req, State={Path, {_, #file_info{size=Size, mtime=Mtime}},
        Extra})</code> - Generate an etag for the file.</p>
<p>-spec generate_etag(Req, State)
    -&gt; {{strong | weak, binary() | undefined}, Req, State}
    when State::state().
- <code>last_modified(Req, State={_, {_, #file_info{mtime=Modified}}, _})</code> - Return the time of last modification of the file.</p>
<p>-spec last_modified(Req, State)
    -&gt; {calendar:datetime(), Req, State}
    when State::state().
- <code>get_file(Req, State={Path, {direct, #file_info{size=Size}}, _})</code> - Stream the file.</p>
<p>-spec get_file(Req, State)
    -&gt; {{sendfile, 0, non_neg_integer(), binary()} | binary(), Req, State}
    when State::state().</p>
<p><strong>Dependencies</strong>: cowboy_req</p>
<hr />
<h3 id="cowboy_stream">cowboy_stream</h3>
<p><strong>File</strong>: <code>/Users/ddleon/.erlviz/cache/ninenines_cowboy/src/cowboy_stream.erl</code></p>
<p><strong>Description</strong>:
Copyright (c) Loïc Hoguin <a href="&#109;&#97;&#105;&#108;&#116;&#111;&#58;&#101;&#115;&#115;&#101;&#110;&#64;&#110;&#105;&#110;&#101;&#110;&#105;&#110;&#101;&#115;&#46;&#101;&#117;">&#101;&#115;&#115;&#101;&#110;&#64;&#110;&#105;&#110;&#101;&#110;&#105;&#110;&#101;&#115;&#46;&#101;&#117;</a>
%% Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted, provided that the above
copyright notice and this permission notice appear in all copies.
%% THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF</p>
<p><strong>Exported Functions</strong>: init/3, data/4, info/3, terminate/3, early_error/5, make_error_log/5</p>
<p><strong>Functions</strong>:</p>
<ul>
<li><code>init(StreamID, Req, Opts)</code> - Copyright (c) Loïc Hoguin <a href="&#109;&#97;&#105;&#108;&#116;&#111;&#58;&#101;&#115;&#115;&#101;&#110;&#64;&#110;&#105;&#110;&#101;&#110;&#105;&#110;&#101;&#115;&#46;&#101;&#117;">&#101;&#115;&#115;&#101;&#110;&#64;&#110;&#105;&#110;&#101;&#110;&#105;&#110;&#101;&#115;&#46;&#101;&#117;</a>
%%
%% Permission to use, copy, modify, and/or distribute this software for any
%% purpose with or without fee is hereby granted, provided that the above
%% copyright notice and this permission notice appear in all copies.
%%
%% THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
%% WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
%% MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
%% ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
%% WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
%% ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
%% OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.</li>
</ul>
<p>-module(cowboy_stream).</p>
<p>-type state() :: any().
-type human_reason() :: atom().</p>
<p>-type streamid() :: any().
-export_type([streamid/0]).</p>
<p>-type fin() :: fin | nofin.
-export_type([fin/0]).</p>
<p>%% @todo Perhaps it makes more sense to have resp_body in this module?</p>
<p>-type resp_command()
    :: {response, cowboy:http_status(), cowboy:http_headers(), cowboy_req:resp_body()}.
-export_type([resp_command/0]).</p>
<p>-type commands() :: [{inform, cowboy:http_status(), cowboy:http_headers()}
    | resp_command()
    | {headers, cowboy:http_status(), cowboy:http_headers()}
    | {data, fin(), cowboy_req:resp_body()}
    | {trailers, cowboy:http_headers()}
    | {push, binary(), binary(), binary(), inet:port_number(),
        binary(), binary(), cowboy:http_headers()}
    | {flow, pos_integer()}
    | {spawn, pid(), timeout()}
    | {error_response, cowboy:http_status(), cowboy:http_headers(), iodata()}
    | {switch_protocol, cowboy:http_headers(), module(), state()}
    | {internal_error, any(), human_reason()}
    | {set_options, map()}
    | {log, logger:level(), io:format(), list()}
    | stop].
-export_type([commands/0]).</p>
<p>-type reason() :: normal | switch_protocol
    | {internal_error, timeout | {error | exit | throw, any()}, human_reason()}
    | {socket_error, closed | atom(), human_reason()}
    %% @todo Or cow_http3:error().
    | {stream_error, cow_http2:error(), human_reason()}
    | {connection_error, cow_http2:error(), human_reason()}
    | {stop, cow_http2:frame() | {exit, any()}, human_reason()}.
-export_type([reason/0]).</p>
<p>-type partial_req() :: map(). %% @todo Take what's in cowboy_req with everything? optional.
-export_type([partial_req/0]).</p>
<p>-callback init(streamid(), cowboy_req:req(), cowboy:opts()) -&gt; {commands(), state()}.
-callback data(streamid(), fin(), binary(), State) -&gt; {commands(), State} when State::state().
-callback info(streamid(), any(), State) -&gt; {commands(), State} when State::state().
-callback terminate(streamid(), reason(), state()) -&gt; any().
-callback early_error(streamid(), reason(), partial_req(), Resp, cowboy:opts())
    -&gt; Resp when Resp::resp_command().</p>
<p>%% @todo To optimize the number of active timers we could have a command
%% that enables a timeout that is called in the absence of any other call,
%% similar to what gen_server does. However the nice thing about this is
%% that the connection process can keep a single timer around (the same
%% one that would be used to detect half-closed sockets) and use this
%% timer and other events to trigger the timeout in streams at their
%% intended time.
%%
%% This same timer can be used to try and send PING frames to help detect
%% that the connection is indeed unresponsive.</p>
<p>-export([init/3]).
-export([data/4]).
-export([info/3]).
-export([terminate/3]).
-export([early_error/5]).
-export([make_error_log/5]).</p>
<p>%% Note that this and other functions in this module do NOT catch
%% exceptions. We want the exception to go all the way down to the
%% protocol code.
%%
%% OK the failure scenario is not so clear. The problem is
%% that the failure at any point in init/3 will result in the
%% corresponding state being lost. I am unfortunately not
%% confident we can do anything about this. If the crashing
%% handler just created a process, we'll never know about it.
%% Therefore at this time I choose to leave all failure handling
%% to the protocol process.
%%
%% Note that a failure in init/3 will result in terminate/3
%% NOT being called. This is because the state is not available.</p>
<p>-spec init(streamid(), cowboy_req:req(), cowboy:opts())
    -&gt; {commands(), {module(), state()} | undefined}.
- <code>data(_, _, _, undefined)</code> - We call the next handler and remove it from the list of
            %% stream handlers. This means that handlers that run after
            %% it have no knowledge it exists. Should user require this
            %% knowledge they can just define a separate option that will
            %% be left untouched.
            {Commands, State} = Handler:init(StreamID, Req, Opts#{stream_handlers =&gt; Tail}),
            {Commands, {Handler, State}}
    end.</p>
<p>-spec data(streamid(), fin(), binary(), {Handler, State} | undefined)
    -&gt; {commands(), {Handler, State} | undefined}
    when Handler::module(), State::state().
- <code>make_error_log(init, [StreamID, Req, Opts], Class, Exception, Stacktrace)</code> - This is the same behavior as in init/3.
            Handler:early_error(StreamID, Reason,
                PartialReq, Resp, Opts#{stream_handlers =&gt; Tail})
    end.</p>
<p>-spec make_error_log(init | data | info | terminate | early_error,
    list(), error | exit | throw, any(), list())
    -&gt; {log, error, string(), list()}.</p>
<p><strong>Dependencies</strong>: cowboy, cowboy_stream, cowboy_req</p>
<hr />
<h3 id="cowboy_stream_h">cowboy_stream_h</h3>
<p><strong>File</strong>: <code>/Users/ddleon/.erlviz/cache/ninenines_cowboy/src/cowboy_stream_h.erl</code></p>
<p><strong>Behaviors</strong>: cowboy_stream</p>
<p><strong>Description</strong>:
Copyright (c) Loïc Hoguin <a href="&#109;&#97;&#105;&#108;&#116;&#111;&#58;&#101;&#115;&#115;&#101;&#110;&#64;&#110;&#105;&#110;&#101;&#110;&#105;&#110;&#101;&#115;&#46;&#101;&#117;">&#101;&#115;&#115;&#101;&#110;&#64;&#110;&#105;&#110;&#101;&#110;&#105;&#110;&#101;&#115;&#46;&#101;&#117;</a>
%% Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted, provided that the above
copyright notice and this permission notice appear in all copies.
%% THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF</p>
<p><strong>Exported Functions</strong>: init/3, data/4, info/3, terminate/3, early_error/5, request_process/3, resume/5</p>
<p><strong>Functions</strong>:</p>
<ul>
<li><code>init(StreamID, Req=#{ref := Ref}, Opts)</code> - Copyright (c) Loïc Hoguin <a href="&#109;&#97;&#105;&#108;&#116;&#111;&#58;&#101;&#115;&#115;&#101;&#110;&#64;&#110;&#105;&#110;&#101;&#110;&#105;&#110;&#101;&#115;&#46;&#101;&#117;">&#101;&#115;&#115;&#101;&#110;&#64;&#110;&#105;&#110;&#101;&#110;&#105;&#110;&#101;&#115;&#46;&#101;&#117;</a>
%%
%% Permission to use, copy, modify, and/or distribute this software for any
%% purpose with or without fee is hereby granted, provided that the above
%% copyright notice and this permission notice appear in all copies.
%%
%% THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
%% WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
%% MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
%% ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
%% WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
%% ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
%% OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.</li>
</ul>
<p>-module(cowboy_stream_h).
-behavior(cowboy_stream).</p>
<p>-export([init/3]).
-export([data/4]).
-export([info/3]).
-export([terminate/3]).
-export([early_error/5]).</p>
<p>-export([request_process/3]).
-export([resume/5]).</p>
<p>-record(state, {
    next :: any(),
    ref = undefined :: ranch:ref(),
    pid = undefined :: pid(),
    expect = undefined :: undefined | continue,
    read_body_pid = undefined :: pid() | undefined,
    read_body_ref = undefined :: reference() | undefined,
    read_body_timer_ref = undefined :: reference() | undefined,
    read_body_length = 0 :: non_neg_integer() | infinity | auto,
    read_body_is_fin = nofin :: nofin | {fin, non_neg_integer()},
    read_body_buffer = &lt;&lt;&gt;&gt; :: binary(),
    body_length = 0 :: non_neg_integer(),
    stream_body_pid = undefined :: pid() | undefined,
    stream_body_status = normal :: normal | blocking | blocked
}).</p>
<p>-spec init(cowboy_stream:streamid(), cowboy_req:req(), cowboy:opts())
    -&gt; {[{spawn, pid(), timeout()}], #state{}}.
- <code>expect(#{version := 'HTTP/1.0'})</code> - Ignore the expect header in HTTP/1.0.
- <code>data(StreamID, IsFin=nofin, Data, State=#state{
        read_body_length=ReadLen, read_body_buffer=Buffer, body_length=BodyLen})
        when byte_size(Data) + byte_size(Buffer) &lt; ReadLen -&gt;
    do_data(StreamID, IsFin, Data, [], State#state{
        expect=undefined,
        read_body_buffer= &lt;&lt; Buffer/binary, Data/binary &gt;&gt;,
        body_length=BodyLen + byte_size(Data)
    });
%% Stream is waiting for data and we received enough to send.
data(StreamID, IsFin, Data, State=#state{read_body_pid=Pid, read_body_ref=Ref,
        read_body_timer_ref=TRef, read_body_buffer=Buffer, body_length=BodyLen0})</code> - @todo This is wrong, it's missing byte_size(Data).
        body_length=BodyLen
    });
%% Stream is waiting for data but we didn't receive enough to send yet.
- <code>info(StreamID, Info, State)</code> - Unknown message, either stray or meant for a handler down the line.
- <code>request_process(Req, Env, Middlewares)</code> - Request process.</p>
<p>%% We add the stacktrace to exit exceptions here in order
%% to simplify the debugging of errors. The proc_lib library
%% already adds the stacktrace to other types of exceptions.
-spec request_process(cowboy_req:req(), cowboy_middleware:env(), [module()]) -&gt; ok.</p>
<p><strong>Dependencies</strong>: cowboy, cowboy_stream, cowboy_req, cowboy_middleware</p>
<hr />
<h3 id="cowboy_sub_protocol">cowboy_sub_protocol</h3>
<p><strong>File</strong>: <code>/Users/ddleon/.erlviz/cache/ninenines_cowboy/src/cowboy_sub_protocol.erl</code></p>
<p><strong>Description</strong>:
Copyright (c) Loïc Hoguin <a href="&#109;&#97;&#105;&#108;&#116;&#111;&#58;&#101;&#115;&#115;&#101;&#110;&#64;&#110;&#105;&#110;&#101;&#110;&#105;&#110;&#101;&#115;&#46;&#101;&#117;">&#101;&#115;&#115;&#101;&#110;&#64;&#110;&#105;&#110;&#101;&#110;&#105;&#110;&#101;&#115;&#46;&#101;&#117;</a>
Copyright (c) James Fish <a href="&#109;&#97;&#105;&#108;&#116;&#111;&#58;&#106;&#97;&#109;&#101;&#115;&#64;&#102;&#105;&#115;&#104;&#99;&#97;&#107;&#101;&#122;&#46;&#99;&#111;&#109;">&#106;&#97;&#109;&#101;&#115;&#64;&#102;&#105;&#115;&#104;&#99;&#97;&#107;&#101;&#122;&#46;&#99;&#111;&#109;</a>
%% Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted, provided that the above
copyright notice and this permission notice appear in all copies.
%% THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN</p>
<p><strong>Dependencies</strong>: cowboy_req, cowboy_middleware</p>
<hr />
<h3 id="cowboy_tls">cowboy_tls</h3>
<p><strong>File</strong>: <code>/Users/ddleon/.erlviz/cache/ninenines_cowboy/src/cowboy_tls.erl</code></p>
<p><strong>Behaviors</strong>: ranch_protocol</p>
<p><strong>Description</strong>:
Copyright (c) Loïc Hoguin <a href="&#109;&#97;&#105;&#108;&#116;&#111;&#58;&#101;&#115;&#115;&#101;&#110;&#64;&#110;&#105;&#110;&#101;&#110;&#105;&#110;&#101;&#115;&#46;&#101;&#117;">&#101;&#115;&#115;&#101;&#110;&#64;&#110;&#105;&#110;&#101;&#110;&#105;&#110;&#101;&#115;&#46;&#101;&#117;</a>
%% Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted, provided that the above
copyright notice and this permission notice appear in all copies.
%% THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF</p>
<p><strong>Exported Functions</strong>: start_link/3, start_link/4, connection_process/4</p>
<p><strong>Functions</strong>:</p>
<ul>
<li><code>start_link(Ref, Transport, Opts)</code> - Ranch 2.
-spec start_link(ranch:ref(), module(), cowboy:opts()) -&gt; {ok, pid()}.</li>
<li><code>init(Parent, Ref, Socket, Transport, ProxyInfo, Opts, Protocol)</code> - http/1.1 or no protocol negotiated.
            Protocol = case maps:get(alpn_default_protocol, Opts, http) of
                http -&gt; cowboy_http;
                http2 -&gt; cowboy_http2
            end,
            init(Parent, Ref, Socket, Transport, ProxyInfo, Opts, Protocol)
    end.</li>
</ul>
<p><strong>Dependencies</strong>: cowboy</p>
<hr />
<h3 id="cowboy_tracer_h">cowboy_tracer_h</h3>
<p><strong>File</strong>: <code>/Users/ddleon/.erlviz/cache/ninenines_cowboy/src/cowboy_tracer_h.erl</code></p>
<p><strong>Behaviors</strong>: cowboy_stream</p>
<p><strong>Description</strong>:
Copyright (c) Loïc Hoguin <a href="&#109;&#97;&#105;&#108;&#116;&#111;&#58;&#101;&#115;&#115;&#101;&#110;&#64;&#110;&#105;&#110;&#101;&#110;&#105;&#110;&#101;&#115;&#46;&#101;&#117;">&#101;&#115;&#115;&#101;&#110;&#64;&#110;&#105;&#110;&#101;&#110;&#105;&#110;&#101;&#115;&#46;&#101;&#117;</a>
%% Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted, provided that the above
copyright notice and this permission notice appear in all copies.
%% THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF</p>
<p><strong>Exported Functions</strong>: init/3, data/4, info/3, terminate/3, early_error/5, set_trace_patterns/0, tracer_process/3, system_continue/3, system_terminate/4, system_code_change/4</p>
<p><strong>Functions</strong>:</p>
<ul>
<li><code>init(StreamID, Req, Opts)</code> - Copyright (c) Loïc Hoguin <a href="&#109;&#97;&#105;&#108;&#116;&#111;&#58;&#101;&#115;&#115;&#101;&#110;&#64;&#110;&#105;&#110;&#101;&#110;&#105;&#110;&#101;&#115;&#46;&#101;&#117;">&#101;&#115;&#115;&#101;&#110;&#64;&#110;&#105;&#110;&#101;&#110;&#105;&#110;&#101;&#115;&#46;&#101;&#117;</a>
%%
%% Permission to use, copy, modify, and/or distribute this software for any
%% purpose with or without fee is hereby granted, provided that the above
%% copyright notice and this permission notice appear in all copies.
%%
%% THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
%% WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
%% MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
%% ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
%% WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
%% ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
%% OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.</li>
</ul>
<p>-module(cowboy_tracer_h).
-behavior(cowboy_stream).</p>
<p>-export([init/3]).
-export([data/4]).
-export([info/3]).
-export([terminate/3]).
-export([early_error/5]).</p>
<p>-export([set_trace_patterns/0]).</p>
<p>-export([tracer_process/3]).
-export([system_continue/3]).
-export([system_terminate/4]).
-export([system_code_change/4]).</p>
<p>-type match_predicate()
    :: fun((cowboy_stream:streamid(), cowboy_req:req(), cowboy:opts()) -&gt; boolean()).</p>
<p>-type tracer_match_specs() :: [match_predicate()
    | {method, binary()}
    | {host, binary()}
    | {path, binary()}
    | {path_start, binary()}
    | {header, binary()}
    | {header, binary(), binary()}
    | {peer_ip, inet:ip_address()}
].
-export_type([tracer_match_specs/0]).</p>
<p>-type tracer_callback() :: fun((init | terminate | tuple(), any()) -&gt; any()).
-export_type([tracer_callback/0]).</p>
<p>-spec init(cowboy_stream:streamid(), cowboy_req:req(), cowboy:opts())
    -&gt; {cowboy_stream:commands(), any()}.
- <code>set_trace_patterns()</code> - API.</p>
<p>%% These trace patterns are most likely not suitable for production.
-spec set_trace_patterns() -&gt; ok.
- <code>init_tracer(_, _, _)</code> - When the options tracer_match_specs or tracer_callback
%% are not provided we do not enable tracing.
- <code>start_tracer(StreamID, Req, Opts)</code> - We only start the tracer if one wasn't started before.
- <code>tracer_process(StreamID, Req=#{pid := Parent}, Opts=#{tracer_callback := Fun})</code> - The default flags are probably not suitable for production.
            Flags = maps:get(tracer_flags, Opts, [
                send, 'receive', call, return_to,
                procs, ports, monotonic_timestamp,
                %% The set_on_spawn flag is necessary to catch events
                %% from request processes.
                set_on_spawn
            ]),
            erlang:trace(self(), true, [{tracer, TracerPid}|Flags]),
            ok;
        _ -&gt;
            ok
    end.</p>
<p>%% Tracer process.</p>
<p>-spec tracer_process(<em>, </em>, _) -&gt; no_return().
- <code>tracer_loop(Parent, Opts=#{tracer_callback := Fun}, State0)</code> - This is necessary because otherwise the tracer could stop
    %% before it has finished processing the events in its queue.
    process_flag(trap_exit, true),
    State = Fun(init, {StreamID, Req, Opts}),
    tracer_loop(Parent, Opts, State).
- <code>system_continue(Parent, _, {Opts, State})</code> - System callbacks.</p>
<p>-spec system_continue(pid(), _, {cowboy:opts(), any()}) -&gt; no_return().</p>
<p><strong>Dependencies</strong>: cowboy, cowboy_stream, cowboy_req</p>
<hr />
<h3 id="cowboy_websocket">cowboy_websocket</h3>
<p><strong>File</strong>: <code>/Users/ddleon/.erlviz/cache/ninenines_cowboy/src/cowboy_websocket.erl</code></p>
<p><strong>Behaviors</strong>: cowboy_sub_protocol</p>
<p><strong>Description</strong>:
Copyright (c) Loïc Hoguin <a href="&#109;&#97;&#105;&#108;&#116;&#111;&#58;&#101;&#115;&#115;&#101;&#110;&#64;&#110;&#105;&#110;&#101;&#110;&#105;&#110;&#101;&#115;&#46;&#101;&#117;">&#101;&#115;&#115;&#101;&#110;&#64;&#110;&#105;&#110;&#101;&#110;&#105;&#110;&#101;&#115;&#46;&#101;&#117;</a>
%% Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted, provided that the above
copyright notice and this permission notice appear in all copies.
%% THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF</p>
<p><strong>Exported Functions</strong>: is_upgrade_request/1, upgrade/4, upgrade/5, takeover/7, loop/3, system_continue/3, system_terminate/4, system_code_change/4</p>
<p><strong>Functions</strong>:</p>
<ul>
<li><code>is_upgrade_request(#{version := Version, method := &lt;&lt;"CONNECT"&gt;&gt;, protocol := Protocol})
        when Version =:= 'HTTP/2'; Version =:= 'HTTP/3' -&gt;
    &lt;&lt;"websocket"&gt;&gt; =:= cowboy_bstr:to_lower(Protocol);
is_upgrade_request(Req=#{version := 'HTTP/1.1', method := &lt;&lt;"GET"&gt;&gt;})</code> - Copyright (c) Loïc Hoguin <a href="&#109;&#97;&#105;&#108;&#116;&#111;&#58;&#101;&#115;&#115;&#101;&#110;&#64;&#110;&#105;&#110;&#101;&#110;&#105;&#110;&#101;&#115;&#46;&#101;&#117;">&#101;&#115;&#115;&#101;&#110;&#64;&#110;&#105;&#110;&#101;&#110;&#105;&#110;&#101;&#115;&#46;&#101;&#117;</a>
%%
%% Permission to use, copy, modify, and/or distribute this software for any
%% purpose with or without fee is hereby granted, provided that the above
%% copyright notice and this permission notice appear in all copies.
%%
%% THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
%% WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
%% MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
%% ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
%% WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
%% ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
%% OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.</li>
</ul>
<p>%% Cowboy supports versions 7 through 17 of the Websocket drafts.
%% It also supports RFC6455, the proposed standard for Websocket.
-module(cowboy_websocket).
-behaviour(cowboy_sub_protocol).</p>
<p>-export([is_upgrade_request/1]).
-export([upgrade/4]).
-export([upgrade/5]).
-export([takeover/7]).
-export([loop/3]).</p>
<p>-export([system_continue/3]).
-export([system_terminate/4]).
-export([system_code_change/4]).</p>
<p>-type commands() :: [cow_ws:frame()
    | {active, boolean()}
    | {deflate, boolean()}
    | {set_options, map()}
    | {shutdown_reason, any()}
].
-export_type([commands/0]).</p>
<p>-type call_result(State) :: {commands(), State} | {commands(), State, hibernate}.</p>
<p>-type deprecated_call_result(State) :: {ok, State}
    | {ok, State, hibernate}
    | {reply, cow_ws:frame() | [cow_ws:frame()], State}
    | {reply, cow_ws:frame() | [cow_ws:frame()], State, hibernate}
    | {stop, State}.</p>
<p>-type terminate_reason() :: normal | stop | timeout
    | remote | {remote, cow_ws:close_code(), binary()}
    | {error, badencoding | badframe | closed | atom()}
    | {crash, error | exit | throw, any()}.</p>
<p>-callback init(Req, any())
    -&gt; {ok | module(), Req, any()}
    | {module(), Req, any(), any()}
    when Req::cowboy_req:req().</p>
<p>-callback websocket_init(State)
    -&gt; call_result(State) | deprecated_call_result(State) when State::any().
-optional_callbacks([websocket_init/1]).</p>
<p>-callback websocket_handle(ping | pong | {text | binary | ping | pong, binary()}, State)
    -&gt; call_result(State) | deprecated_call_result(State) when State::any().
-callback websocket_info(any(), State)
    -&gt; call_result(State) | deprecated_call_result(State) when State::any().</p>
<p>-callback terminate(any(), cowboy_req:req(), any()) -&gt; ok.
-optional_callbacks([terminate/3]).</p>
<p>-type opts() :: #{
    active_n =&gt; pos_integer(),
    compress =&gt; boolean(),
    deflate_opts =&gt; cow_ws:deflate_opts(),
    dynamic_buffer =&gt; false | {pos_integer(), pos_integer()},
    dynamic_buffer_initial_average =&gt; non_neg_integer(),
    dynamic_buffer_initial_size =&gt; pos_integer(),
    idle_timeout =&gt; timeout(),
    max_frame_size =&gt; non_neg_integer() | infinity,
    req_filter =&gt; fun((cowboy_req:req()) -&gt; map()),
    validate_utf8 =&gt; boolean()
}.
-export_type([opts/0]).</p>
<p>%% We don't want to reset the idle timeout too often,
%% so we don't reset it on data. Instead we reset the
%% number of ticks we have observed. We divide the
%% timeout value by a value and that value becomes
%% the number of ticks at which point we can drop
%% the connection. This value is the number of ticks.
-define(IDLE_TIMEOUT_TICKS, 10).</p>
<p>-record(state, {
    parent :: undefined | pid(),
    ref :: ranch:ref(),
    socket = undefined :: inet:socket() | {pid(), cowboy_stream:streamid()} | undefined,
    transport = undefined :: module() | undefined,
    opts = #{} :: opts(),
    active = true :: boolean(),
    handler :: module(),
    key = undefined :: undefined | binary(),
    timeout_ref = undefined :: undefined | reference(),
    timeout_num = 0 :: 0..?IDLE_TIMEOUT_TICKS,
    messages = undefined :: undefined | {atom(), atom(), atom()}
        | {atom(), atom(), atom(), atom()},</p>
<div class="codehilite"><pre><span></span><code><span class="c">%% Dynamic buffer moving average and current buffer size.</span>
<span class="n">dynamic_buffer_size</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nb">false</span><span class="w"> </span><span class="p">::</span><span class="w"> </span><span class="n">pos_integer</span><span class="p">()</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="nb">false</span><span class="p">,</span>
<span class="n">dynamic_buffer_moving_average</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">::</span><span class="w"> </span><span class="n">non_neg_integer</span><span class="p">(),</span>

<span class="n">hibernate</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nb">false</span><span class="w"> </span><span class="p">::</span><span class="w"> </span><span class="n">boolean</span><span class="p">(),</span>
<span class="n">frag_state</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="n">undefined</span><span class="w"> </span><span class="p">::</span><span class="w"> </span><span class="n">cow_ws</span><span class="p">:</span><span class="n">frag_state</span><span class="p">(),</span>
<span class="n">frag_buffer</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="o">&lt;&lt;&gt;&gt;</span><span class="w"> </span><span class="p">::</span><span class="w"> </span><span class="nb">binary</span><span class="p">(),</span>
<span class="n">utf8_state</span><span class="w"> </span><span class="s">::</span><span class="w"> </span><span class="s">cow_ws:utf8_state(),</span>
<span class="n">deflate</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nb">true</span><span class="w"> </span><span class="p">::</span><span class="w"> </span><span class="n">boolean</span><span class="p">(),</span>
<span class="n">extensions</span><span class="w"> </span><span class="p">=</span><span class="w"> </span>#<span class="p">{}</span><span class="w"> </span><span class="p">::</span><span class="w"> </span><span class="n">map</span><span class="p">(),</span>
<span class="n">req</span><span class="w"> </span><span class="p">=</span><span class="w"> </span>#<span class="p">{}</span><span class="w"> </span><span class="p">::</span><span class="w"> </span><span class="n">map</span><span class="p">(),</span>
<span class="n">shutdown_reason</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="n">normal</span><span class="w"> </span><span class="p">::</span><span class="w"> </span><span class="nb">any</span><span class="p">()</span>
</code></pre></div>

<p>}).</p>
<p>%% Because the HTTP/1.1 and HTTP/2 handshakes are so different,
%% this function is necessary to figure out whether a request
%% is trying to upgrade to the Websocket protocol.</p>
<p>-spec is_upgrade_request(cowboy_req:req()) -&gt; boolean().
- <code>upgrade(Req0=#{version := Version}, Env, Handler, HandlerState, Opts)</code> - @todo Immediately crash if a response has already been sent.
- <code>websocket_upgrade(State, Req=#{version := Version})</code> - The status code 426 is specific to HTTP/1.1 connections.
        {error, upgrade_required} when Version =:= 'HTTP/1.1' -&gt;
            {ok, cowboy_req:reply(426, #{
                &lt;&lt;"connection"&gt;&gt; =&gt; &lt;&lt;"upgrade"&gt;&gt;,
                &lt;&lt;"upgrade"&gt;&gt; =&gt; &lt;&lt;"websocket"&gt;&gt;
            }, Req0), Env};
        %% Use 501 Not Implemented for HTTP/2 and HTTP/3 as recommended
        %% by RFC9220 3 (WebSockets Upgrade over HTTP/3).
        {error, upgrade_required} -&gt;
            {ok, cowboy_req:reply(501, Req0), Env}
    catch <em>:</em> -&gt;
        %% @todo Probably log something here?
        %% @todo Test that we can have 2 /ws 400 status code in a row on the same connection.
        {ok, cowboy_req:reply(400, Req0), Env}
    end.
- <code>websocket_extensions(State=#state{opts=Opts, extensions=Extensions},
        Req=#{pid := Pid, version := Version},
        [{&lt;&lt;"permessage-deflate"&gt;&gt;, Params}|Tail], RespHeader)</code> - For HTTP/2 we ARE on the controlling process and do NOT want to update the owner.
- <code>websocket_handshake(State, Req=#{ref := Ref, pid := Pid, streamid := StreamID},
        HandlerState, _Env)</code> - @todo We don't want date and server headers.
    Headers = cowboy_req:response_headers(#{
        &lt;&lt;"connection"&gt;&gt; =&gt; &lt;&lt;"Upgrade"&gt;&gt;,
        &lt;&lt;"upgrade"&gt;&gt; =&gt; &lt;&lt;"websocket"&gt;&gt;,
        &lt;&lt;"sec-websocket-accept"&gt;&gt; =&gt; Challenge
    }, Req),
    Pid ! {{Pid, StreamID}, {switch_protocol, Headers, ?MODULE, {State, HandlerState}}},
    {ok, Req, Env};
%% For HTTP/2 we do not let the process die, we instead keep it
%% for the Websocket stream. This is because in HTTP/2 we only
%% have a stream, it doesn't take over the whole connection.
- <code>takeover(Parent, Ref, Socket, Transport, Opts, Buffer,
        {State0=#state{opts=WsOpts, handler=Handler, req=Req}, HandlerState})</code> - @todo We don't want date and server headers.
    Headers = cowboy_req:response_headers(#{}, Req),
    Pid ! {{Pid, StreamID}, {switch_protocol, Headers, ?MODULE, {State, HandlerState}}},
    takeover(Pid, Ref, {Pid, StreamID}, undefined, #{}, &lt;&lt;&gt;&gt;,
        {State, HandlerState}).</p>
<p>%% Connection process.</p>
<p>-record(ps_header, {
    buffer = &lt;&lt;&gt;&gt; :: binary()
}).</p>
<p>-record(ps_payload, {
    type :: cow_ws:frame_type(),
    len :: non_neg_integer(),
    mask_key :: cow_ws:mask_key(),
    rsv :: cow_ws:rsv(),
    close_code = undefined :: undefined | cow_ws:close_code(),
    unmasked = &lt;&lt;&gt;&gt; :: binary(),
    unmasked_len = 0 :: non_neg_integer(),
    buffer = &lt;&lt;&gt;&gt; :: binary()
}).</p>
<p>-type parse_state() :: #ps_header{} | #ps_payload{}.</p>
<p>-spec takeover(pid(), ranch:ref(), inet:socket() | {pid(), cowboy_stream:streamid()},
    module() | undefined, any(), binary(),
    {#state{}, any()}) -&gt; no_return().
- <code>maybe_socket_error(_, _)</code> - @todo We should have an option to disable this behavior.
        _ -&gt; ranch:remove_connection(Ref)
    end,
    Messages = case Transport of
        undefined -&gt; undefined;
        _ -&gt; Transport:messages()
    end,
    State = set_idle_timeout(State0#state{parent=Parent,
        ref=Ref, socket=Socket, transport=Transport,
        opts=WsOpts#{dynamic_buffer =&gt; maps:get(dynamic_buffer, Opts, false)},
        key=undefined, messages=Messages,
        %% Dynamic buffer only applies to HTTP/1.1 Websocket.
        dynamic_buffer_size=init_dynamic_buffer_size(Opts),
        dynamic_buffer_moving_average=maps:get(dynamic_buffer_initial_average, Opts, 0)}, 0),
    %% We call parse_header/3 immediately because there might be
    %% some data in the buffer that was sent along with the handshake.
    %% While it is not allowed by the protocol to send frames immediately,
    %% we still want to process that data if any.
    case erlang:function_exported(Handler, websocket_init, 1) of
        true -&gt; handler_call(State, HandlerState, #ps_header{buffer=Buffer},
            websocket_init, undefined, fun after_init/3);
        false -&gt; after_init(State, HandlerState, #ps_header{buffer=Buffer})
    end.</p>
<p>-include("cowboy_dynamic_buffer.hrl").</p>
<p>%% @todo Implement early socket error detection.
- <code>after_init(State, HandlerState, ParseState)</code> - Enable active,N for HTTP/1.1, and auto read_body for HTTP/2.
    %% We must do this only after calling websocket_init/1 (if any)
    %% to give the handler a chance to disable active mode immediately.
    setopts_active(State),
    maybe_read_body(State),
    parse_header(State, HandlerState, ParseState);
- <code>setopts_active(#state{transport=undefined})</code> - We have two ways of reading the body for Websocket. For HTTP/1.1
%% we have full control of the socket and can therefore use active,N.
%% For HTTP/2 we are just a stream, and are instead using read_body
%% (automatic mode). Technically HTTP/2 will only go passive after
%% receiving the next data message, while HTTP/1.1 goes passive
%% immediately but there might still be data to be processed in
%% the message queue.
- <code>maybe_read_body(_)</code> - @todo Keep Ref around.
    ReadBodyRef = make_ref(),
    Pid ! {Stream, {read_body, self(), ReadBodyRef, auto, infinity}},
    ok;
- <code>passive(State=#state{socket=Socket, transport=Transport, messages=Messages})</code> - Unfortunately we cannot currently cancel read_body.
    %% But that's OK, we will just stop reading the body
    %% after the next message.
    State#state{active=false};
- <code>before_loop(State=#state{hibernate=true}, HandlerState, ParseState)</code> - Hardcoded for compatibility with Ranch 1.x.
                Passive =:= tcp_passive; Passive =:= ssl_passive -&gt;
            flush_passive(Socket, Messages)
    after 0 -&gt;
        ok
    end.
- <code>set_idle_timeout(State=#state{opts=Opts, timeout_ref=PrevRef}, TimeoutNum)</code> - @todo Do we really need this for HTTP/2?
- <code>tick_idle_timeout(State=#state{timeout_num=?IDLE_TIMEOUT_TICKS}, HandlerState, _)</code> - Most of the time we don't need to cancel the timer since it
    %% will have triggered already. But this call is harmless so
    %% it is kept to simplify the code as we do need to cancel when
    %% options are changed dynamically.
    _ = case PrevRef of
        undefined -&gt; ignore;
        PrevRef -&gt; erlang:cancel_timer(PrevRef, [{async, true}, {info, false}])
    end,
    case maps:get(idle_timeout, Opts, 60000) of
        infinity -&gt;
            State#state{timeout_ref=undefined, timeout_num=TimeoutNum};
        Timeout -&gt;
            TRef = erlang:start_timer(Timeout div ?IDLE_TIMEOUT_TICKS, self(), ?MODULE),
            State#state{timeout_ref=TRef, timeout_num=TimeoutNum}
    end.</p>
<p>-define(reset_idle_timeout(State), State#state{timeout_num=0}).
- <code>parse(State, HandlerState, PS=#ps_header{buffer=Buffer}, Data)</code> - Socket messages. (HTTP/1.1)
        {OK, Socket, Data} when OK =:= element(1, Messages) -&gt;
            State1 = maybe_resize_buffer(State, Data),
            parse(?reset_idle_timeout(State1), HandlerState, ParseState, Data);
        {Closed, Socket} when Closed =:= element(2, Messages) -&gt;
            terminate(State, HandlerState, {error, closed});
        {Error, Socket, Reason} when Error =:= element(3, Messages) -&gt;
            terminate(State, HandlerState, {error, Reason});
        {Passive, Socket} when Passive =:= element(4, Messages);
                %% Hardcoded for compatibility with Ranch 1.x.
                Passive =:= tcp_passive; Passive =:= ssl_passive -&gt;
            setopts_active(State),
            loop(State, HandlerState, ParseState);
        %% Body reading messages. (HTTP/2)
        {request_body, <em>Ref, nofin, Data} -&gt;
            maybe_read_body(State),
            parse(?reset_idle_timeout(State), HandlerState, ParseState, Data);
        %% @todo We need to handle this case as if it was an {error, closed}
        %% but not before we finish processing frames. We probably should have
        %% a check in before_loop to let us stop looping if a flag is set.
        {request_body, _Ref, fin, </em>, Data} -&gt;
            maybe_read_body(State),
            parse(?reset_idle_timeout(State), HandlerState, ParseState, Data);
        %% Timeouts.
        {timeout, TRef, ?MODULE} -&gt;
            tick_idle_timeout(State, HandlerState, ParseState);
        {timeout, OlderTRef, ?MODULE} when is_reference(OlderTRef) -&gt;
            before_loop(State, HandlerState, ParseState);
        %% System messages.
        {'EXIT', Parent, Reason} -&gt;
            %% @todo We should exit gracefully.
            exit(Reason);
        {system, From, Request} -&gt;
            sys:handle_system_msg(Request, From, Parent, ?MODULE, [],
                {State, HandlerState, ParseState});
        %% Calls from supervisor module.
        {'$gen_call', From, Call} -&gt;
            cowboy_children:handle_supervisor_call(Call, From, [], ?MODULE),
            before_loop(State, HandlerState, ParseState);
        Message -&gt;
            handler_call(State, HandlerState, ParseState,
                websocket_info, Message, fun before_loop/3)
    end.
- <code>parse_payload(State=#state{opts=Opts, frag_state=FragState, utf8_state=Incomplete, extensions=Extensions},
        HandlerState, ParseState=#ps_payload{
            type=Type, len=Len, mask_key=MaskKey, rsv=Rsv,
            unmasked=Unmasked, unmasked_len=UnmaskedLen}, Data)</code> - All frames sent from the client to the server are masked.
        {<em>, </em>, <em>, </em>, undefined, <em>} -&gt;
            websocket_close(State, HandlerState, {error, badframe});
        {</em>, <em>, </em>, Len, <em>, </em>} when Len &gt; MaxFrameSize -&gt;
            websocket_close(State, HandlerState, {error, badsize});
        {Type, FragState2, Rsv, Len, MaskKey, Rest} -&gt;
            parse_payload(State#state{frag_state=FragState2}, HandlerState,
                #ps_payload{type=Type, len=Len, mask_key=MaskKey, rsv=Rsv}, Rest);
        more -&gt;
            before_loop(State, HandlerState, ParseState);
        error -&gt;
            websocket_close(State, HandlerState, {error, badframe})
    end.
- <code>handler_call(State=#state{handler=Handler}, HandlerState,
        ParseState, Callback, Message, NextState)</code> - @todo Allow receiving fragments.
        {fragment, <em>, </em>, Payload} when byte_size(Payload) + byte_size(SoFar) &gt; MaxFrameSize -&gt;
            websocket_close(State, HandlerState, {error, badsize});
        {fragment, nofin, <em>, Payload} -&gt;
            parse_header(State#state{frag_buffer= &lt;&lt; SoFar/binary, Payload/binary &gt;&gt;},
                HandlerState, #ps_header{buffer=RemainingData});
        {fragment, fin, Type, Payload} -&gt;
            handler_call(State#state{frag_state=undefined, frag_buffer= &lt;&lt;&gt;&gt;}, HandlerState,
                #ps_header{buffer=RemainingData},
                websocket_handle, {Type, &lt;&lt; SoFar/binary, Payload/binary &gt;&gt;},
                fun parse_header/3);
        close -&gt;
            websocket_close(State, HandlerState, remote);
        {close, CloseCode, Payload} -&gt;
            websocket_close(State, HandlerState, {remote, CloseCode, Payload});
        Frame = ping -&gt;
            transport_send(State, nofin, frame(pong, State)),
            handler_call(State, HandlerState,
                #ps_header{buffer=RemainingData},
                websocket_handle, Frame, fun parse_header/3);
        Frame = {ping, Payload} -&gt;
            transport_send(State, nofin, frame({pong, Payload}, State)),
            handler_call(State, HandlerState,
                #ps_header{buffer=RemainingData},
                websocket_handle, Frame, fun parse_header/3);
        Frame -&gt;
            handler_call(State, HandlerState,
                #ps_header{buffer=RemainingData},
                websocket_handle, Frame, fun parse_header/3)
    end.
- <code>handler_call_result(State0, HandlerState, ParseState, NextState, Commands)</code> - The following call results are deprecated.
        {ok, HandlerState2} -&gt;
            NextState(State, HandlerState2, ParseState);
        {ok, HandlerState2, hibernate} -&gt;
            NextState(State#state{hibernate=true}, HandlerState2, ParseState);
        {reply, Payload, HandlerState2} -&gt;
            case websocket_send(Payload, State) of
                ok -&gt;
                    NextState(State, HandlerState2, ParseState);
                stop -&gt;
                    terminate(State, HandlerState2, stop);
                Error = {error, </em>} -&gt;
                    terminate(State, HandlerState2, Error)
            end;
        {reply, Payload, HandlerState2, hibernate} -&gt;
            case websocket_send(Payload, State) of
                ok -&gt;
                    NextState(State#state{hibernate=true},
                        HandlerState2, ParseState);
                stop -&gt;
                    terminate(State, HandlerState2, stop);
                Error = {error, _} -&gt;
                    terminate(State, HandlerState2, Error)
            end;
        {stop, HandlerState2} -&gt;
            websocket_close(State, HandlerState2, stop)
    catch Class:Reason:Stacktrace -&gt;
        websocket_send_close(State, {crash, Class, Reason}),
        handler_terminate(State, HandlerState, {crash, Class, Reason}),
        erlang:raise(Class, Reason, Stacktrace)
    end.</p>
<p>-spec handler_call_result(#state{}, any(), parse_state(), fun(), commands()) -&gt; no_return().
- <code>commands([{shutdown_reason, ShutdownReason}|Tail], State, Data)</code> - We reset the number of ticks when changing the idle_timeout option.
            set_idle_timeout(StateF#state{opts=Opts#{idle_timeout =&gt; IdleTimeout}}, 0);
        (max_frame_size, MaxFrameSize, StateF=#state{opts=Opts}) -&gt;
            StateF#state{opts=Opts#{max_frame_size =&gt; MaxFrameSize}};
        (<em>, </em>, StateF) -&gt;
            StateF
    end, State0, SetOpts),
    commands(Tail, State, Data);
- <code>frame(Frame, #state{deflate=false, extensions=Extensions})</code> - Don't compress frames while deflate is disabled.
- <code>system_continue(_, _, {State, HandlerState, ParseState})</code> - System callbacks.</p>
<p>-spec system_continue(<em>, </em>, {#state{}, any(), parse_state()}) -&gt; no_return().
- <code>system_code_change(Misc, _, _, _)</code> - @todo We should exit gracefully, if possible.
    terminate(State, HandlerState, Reason).</p>
<p>-spec system_code_change(Misc, <em>, </em>, _)
    -&gt; {ok, Misc} when Misc::{#state{}, any(), parse_state()}.</p>
<p><strong>Dependencies</strong>: cowboy_req, cowboy_middleware, cowboy_bstr, cowboy_handler, cowboy_stream, cowboy_children</p>
<hr />
<h3 id="cowboy_webtransport">cowboy_webtransport</h3>
<p><strong>File</strong>: <code>/Users/ddleon/.erlviz/cache/ninenines_cowboy/src/cowboy_webtransport.erl</code></p>
<p><strong>Description</strong>:
Copyright (c) Loïc Hoguin <a href="&#109;&#97;&#105;&#108;&#116;&#111;&#58;&#101;&#115;&#115;&#101;&#110;&#64;&#110;&#105;&#110;&#101;&#110;&#105;&#110;&#101;&#115;&#46;&#101;&#117;">&#101;&#115;&#115;&#101;&#110;&#64;&#110;&#105;&#110;&#101;&#110;&#105;&#110;&#101;&#115;&#46;&#101;&#117;</a>
%% Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted, provided that the above
copyright notice and this permission notice appear in all copies.
%% THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF</p>
<p><strong>Exported Functions</strong>: upgrade/4, upgrade/5, info/3, terminate/3</p>
<p><strong>Functions</strong>:</p>
<ul>
<li>`is_upgrade_request(#{version := Version, method := &lt;&lt;"CONNECT"&gt;&gt;, protocol := Protocol})
        when Version =:= 'HTTP/3' -&gt;
    %% @todo scheme MUST BE "https"
    &lt;&lt;"webtransport"&gt;&gt; =:= cowboy_bstr:to_lower(Protocol);</li>
</ul>
<p>is_upgrade_request(_)` - Copyright (c) Loïc Hoguin <a href="&#109;&#97;&#105;&#108;&#116;&#111;&#58;&#101;&#115;&#115;&#101;&#110;&#64;&#110;&#105;&#110;&#101;&#110;&#105;&#110;&#101;&#115;&#46;&#101;&#117;">&#101;&#115;&#115;&#101;&#110;&#64;&#110;&#105;&#110;&#101;&#110;&#105;&#110;&#101;&#115;&#46;&#101;&#117;</a>
%%
%% Permission to use, copy, modify, and/or distribute this software for any
%% purpose with or without fee is hereby granted, provided that the above
%% copyright notice and this permission notice appear in all copies.
%%
%% THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
%% WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
%% MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
%% ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
%% WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
%% ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
%% OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.</p>
<p>%% @todo To enable WebTransport the following options need to be set:
%%
%% QUIC:
%%  - max_datagram_frame_size &gt; 0
%%
%% HTTP/3:
%%  - SETTINGS_H3_DATAGRAM = 1
%%  - SETTINGS_ENABLE_CONNECT_PROTOCOL = 1
%%  - SETTINGS_WT_MAX_SESSIONS &gt;= 1</p>
<p>%% Cowboy supports versions 07 through 13 of the WebTransport drafts.
%% Cowboy also has some compatibility with version 02.
%%
%% WebTransport CONNECT requests go through cowboy_stream as normal
%% and then an upgrade/switch_protocol is issued (just like Websocket).
%% After that point none of the events go through cowboy_stream except
%% the final terminate event. The request process becomes the process
%% handling all events in the WebTransport session.
%%
%% WebTransport sessions can be ended via a command, via a crash or
%% exit, via the closing of the connection (client or server inititated),
%% via the client ending the session (mirroring the command) or via
%% the client terminating the CONNECT stream.
-module(cowboy_webtransport).</p>
<p>-export([upgrade/4]).
-export([upgrade/5]).</p>
<p>%% cowboy_stream.
-export([info/3]).
-export([terminate/3]).</p>
<p>-type stream_type() :: unidi | bidi.
-type open_stream_ref() :: any().</p>
<p>-type event() ::
    {stream_open, cow_http3:stream_id(), stream_type()} |
    {opened_stream_id, open_stream_ref(), cow_http3:stream_id()} |
    {stream_data, cow_http3:stream_id(), cow_http:fin(), binary()} |
    {datagram, binary()} |
    close_initiated.</p>
<p>-type commands() :: [
    {open_stream, open_stream_ref(), stream_type(), iodata()} |
    {close_stream, cow_http3:stream_id(), cow_http3:wt_app_error_code()} |
    {send, cow_http3:stream_id() | datagram, iodata()} |
    initiate_close |
    close |
    {close, cow_http3:wt_app_error_code()} |
    {close, cow_http3:wt_app_error_code(), iodata()}
].
-export_type([commands/0]).</p>
<p>-type call_result(State) :: {commands(), State} | {commands(), State, hibernate}.</p>
<p>-callback init(Req, any())
    -&gt; {ok | module(), Req, any()}
    | {module(), Req, any(), any()}
    when Req::cowboy_req:req().</p>
<p>-callback webtransport_init(State)
    -&gt; call_result(State) when State::any().
-optional_callbacks([webtransport_init/1]).</p>
<p>-callback webtransport_handle(event(), State)
    -&gt; call_result(State) when State::any().
-optional_callbacks([webtransport_handle/2]).</p>
<p>-callback webtransport_info(any(), State)
    -&gt; call_result(State) when State::any().
-optional_callbacks([webtransport_info/2]).</p>
<p>-callback terminate(any(), cowboy_req:req(), any()) -&gt; ok.
-optional_callbacks([terminate/3]).</p>
<p>-type opts() :: #{
    req_filter =&gt; fun((cowboy_req:req()) -&gt; map())
}.
-export_type([opts/0]).</p>
<p>-record(state, {
    id :: cow_http3:stream_id(),
    parent :: pid(),
    opts = #{} :: opts(),
    handler :: module(),
    hibernate = false :: boolean(),
    req = #{} :: map()
}).</p>
<p>%% This function mirrors a similar function for Websocket.</p>
<p>-spec is_upgrade_request(cowboy_req:req()) -&gt; boolean().
- <code>upgrade(Req=#{version := 'HTTP/3', pid := Pid, streamid := StreamID}, Env, Handler, HandlerState, Opts)</code> - @todo Immediately crash if a response has already been sent.
- <code>webtransport_init(State=#state{handler=Handler}, HandlerState)</code> - @todo Must ensure the relevant settings are enabled (QUIC and H3).
    %% Either we check them BEFORE, or we check them when the handler
    %% is OK to initiate a webtransport session. Probably need to
    %% check them BEFORE as we need to become (takeover) the webtransport process
    %% after we are done with the upgrade. Maybe in cow_http3_machine but
    %% it doesn't have QUIC settings currently (max_datagram_size).
    case is_upgrade_request(Req) of
        true -&gt;
            Headers = cowboy_req:response_headers(#{}, Req),
            Pid ! {{Pid, StreamID}, {switch_protocol, Headers, ?MODULE,
                #{session_pid =&gt; self()}}},
            webtransport_init(State, HandlerState);
        %% Use 501 Not Implemented to mirror the recommendation in
        %% by RFC9220 3 (WebSockets Upgrade over HTTP/3).
        false -&gt;
            %% @todo I don't think terminate will be called.
            {ok, cowboy_req:reply(501, Req), Env}
    end.
- <code>handler_call(State=#state{handler=Handler}, HandlerState, Callback, Message)</code> - Timeouts.
%% @todo idle_timeout
%       {timeout, TRef, ?MODULE} -&gt;
%           tick_idle_timeout(State, HandlerState, ParseState);
%       {timeout, OlderTRef, ?MODULE} when is_reference(OlderTRef) -&gt;
%           before_loop(State, HandlerState, ParseState);
        %% System messages.
        {'EXIT', Parent, Reason} -&gt;
            %% @todo We should exit gracefully.
            exit(Reason);
        {system, From, Request} -&gt;
            sys:handle_system_msg(Request, From, Parent, ?MODULE, [],
                {State, HandlerState});
        %% Calls from supervisor module.
        {'$gen_call', From, Call} -&gt;
            cowboy_children:handle_supervisor_call(Call, From, [], ?MODULE),
            before_loop(State, HandlerState);
        Message -&gt;
            handler_call(State, HandlerState, webtransport_info, Message)
    end.
- <code>handler_call_result(State0, HandlerState, Commands)</code> - @todo Do we need to send a close? Let cowboy_http3 detect and handle it?
        handler_terminate(State, HandlerState, {crash, Class, Reason}),
        erlang:raise(Class, Reason, Stacktrace)
    end.
- <code>commands([Command=close|Tail], State, _, Acc)</code> - close | {close, Code} | {close, Code, Msg} - CLOSE_WT_SESSION
%% @todo At this point the handler must not issue stream or send commands.
- <code>terminate_proc(State, HandlerState, Reason)</code> - @todo A set_options command could be useful to increase the number of allowed streams
%%       or other forms of flow control. Alternatively a flow command. Or both.
%% @todo A shutdown_reason command could be useful for the same reasons as Websocekt.</p>
<p>-spec terminate_proc(<em>, </em>, _) -&gt; no_return().
- <code>handler_terminate(#state{handler=Handler, req=Req}, HandlerState, Reason)</code> - @todo This is what should be done if shutdown_reason gets implemented.
%   case Shutdown of
%       normal -&gt; exit(normal);
%       _ -&gt; exit({shutdown, Shutdown})
%   end.
    exit(normal).
- <code>info(StreamID, Msg, WTState=#{stream_state := StreamState0})</code> - cowboy_stream callbacks.
%%
%% We shortcut stream handlers but still need to process some events
%% such as process exiting or termination. We implement the relevant
%% callbacks here. Note that as far as WebTransport is concerned,
%% receiving stream data here would be an error therefore the data
%% callback is not implemented.
%%
%% @todo Better type than map() for the cowboy_stream state.</p>
<p>-spec info(cowboy_stream:streamid(), any(), State)
    -&gt; {cowboy_stream:commands(), State} when State::map().</p>
<p><strong>Dependencies</strong>: cowboy_req, cowboy_bstr, cowboy_middleware, cowboy_handler, cowboy_stream, cowboy_children</p>
<hr />
<h2 id="supervisor-modules">Supervisor Modules</h2>
<h3 id="cowboy_sup">cowboy_sup</h3>
<p><strong>File</strong>: <code>/Users/ddleon/.erlviz/cache/ninenines_cowboy/src/cowboy_sup.erl</code></p>
<p><strong>Behaviors</strong>: supervisor</p>
<p><strong>Description</strong>:
Copyright (c) Loïc Hoguin <a href="&#109;&#97;&#105;&#108;&#116;&#111;&#58;&#101;&#115;&#115;&#101;&#110;&#64;&#110;&#105;&#110;&#101;&#110;&#105;&#110;&#101;&#115;&#46;&#101;&#117;">&#101;&#115;&#115;&#101;&#110;&#64;&#110;&#105;&#110;&#101;&#110;&#105;&#110;&#101;&#115;&#46;&#101;&#117;</a>
%% Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted, provided that the above
copyright notice and this permission notice appear in all copies.
%% THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF</p>
<p><strong>Exported Functions</strong>: start_link/0, init/1</p>
<p><strong>Functions</strong>:</p>
<ul>
<li><code>start_link()</code> - Copyright (c) Loïc Hoguin <a href="&#109;&#97;&#105;&#108;&#116;&#111;&#58;&#101;&#115;&#115;&#101;&#110;&#64;&#110;&#105;&#110;&#101;&#110;&#105;&#110;&#101;&#115;&#46;&#101;&#117;">&#101;&#115;&#115;&#101;&#110;&#64;&#110;&#105;&#110;&#101;&#110;&#105;&#110;&#101;&#115;&#46;&#101;&#117;</a>
%%
%% Permission to use, copy, modify, and/or distribute this software for any
%% purpose with or without fee is hereby granted, provided that the above
%% copyright notice and this permission notice appear in all copies.
%%
%% THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
%% WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
%% MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
%% ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
%% WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
%% ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
%% OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.</li>
</ul>
<p>-module(cowboy_sup).
-behaviour(supervisor).</p>
<p>-export([start_link/0]).
-export([init/1]).</p>
<p>-spec start_link() -&gt; {ok, pid()}.</p>
<hr />
<h2 id="behavior-modules">Behavior Modules</h2>
<h3 id="cowboy_clock">cowboy_clock</h3>
<p><strong>File</strong>: <code>/Users/ddleon/.erlviz/cache/ninenines_cowboy/src/cowboy_clock.erl</code></p>
<p><strong>Behaviors</strong>: gen_server</p>
<p><strong>Description</strong>:
Copyright (c) Loïc Hoguin <a href="&#109;&#97;&#105;&#108;&#116;&#111;&#58;&#101;&#115;&#115;&#101;&#110;&#64;&#110;&#105;&#110;&#101;&#110;&#105;&#110;&#101;&#115;&#46;&#101;&#117;">&#101;&#115;&#115;&#101;&#110;&#64;&#110;&#105;&#110;&#101;&#110;&#105;&#110;&#101;&#115;&#46;&#101;&#117;</a>
%% Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted, provided that the above
copyright notice and this permission notice appear in all copies.
%% THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF</p>
<p><strong>Exported Functions</strong>: start_link/0, stop/0, rfc1123/0, rfc1123/1, init/1, handle_call/3, handle_cast/2, handle_info/2, terminate/2, code_change/3</p>
<p><strong>Functions</strong>:</p>
<ul>
<li><code>start_link()</code> - Copyright (c) Loïc Hoguin <a href="&#109;&#97;&#105;&#108;&#116;&#111;&#58;&#101;&#115;&#115;&#101;&#110;&#64;&#110;&#105;&#110;&#101;&#110;&#105;&#110;&#101;&#115;&#46;&#101;&#117;">&#101;&#115;&#115;&#101;&#110;&#64;&#110;&#105;&#110;&#101;&#110;&#105;&#110;&#101;&#115;&#46;&#101;&#117;</a>
%%
%% Permission to use, copy, modify, and/or distribute this software for any
%% purpose with or without fee is hereby granted, provided that the above
%% copyright notice and this permission notice appear in all copies.
%%
%% THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
%% WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
%% MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
%% ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
%% WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
%% ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
%% OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.</li>
</ul>
<p>%% While a gen_server process runs in the background to update
%% the cache of formatted dates every second, all API calls are
%% local and directly read from the ETS cache table, providing
%% fast time and date computations.
-module(cowboy_clock).
-behaviour(gen_server).</p>
<p>%% API.
-export([start_link/0]).
-export([stop/0]).
-export([rfc1123/0]).
-export([rfc1123/1]).</p>
<p>%% gen_server.
-export([init/1]).
-export([handle_call/3]).
-export([handle_cast/2]).
-export([handle_info/2]).
-export([terminate/2]).
-export([code_change/3]).</p>
<p>-record(state, {
    universaltime = undefined :: undefined | calendar:datetime(),
    rfc1123 = &lt;&lt;&gt;&gt; :: binary(),
    tref = undefined :: undefined | reference()
}).</p>
<p>%% API.</p>
<p>-spec start_link() -&gt; {ok, pid()}.
- <code>rfc1123()</code> - When the ets table doesn't exist, either because of a bug
%% or because Cowboy is being restarted, we perform in a
%% slightly degraded state and build a new timestamp for
%% every request.
-spec rfc1123() -&gt; binary().
- <code>init([])</code> - gen_server.</p>
<p>-spec init([]) -&gt; {ok, #state{}}.
- <code>handle_info(_Info, State)</code> - Cancel the timer in case an external process sent an update message.
    _ = erlang:cancel_timer(TRef0, [{async, true}, {info, false}]),
    T = erlang:universaltime(),
    B2 = update_rfc1123(B1, Prev, T),
    ets:insert(?MODULE, {rfc1123, B2}),
    TRef = erlang:send_after(1000, self(), update),
    {noreply, #state{universaltime=T, rfc1123=B2, tref=TRef}};
- <code>update_rfc1123(Bin, Now, Now)</code> - Internal.</p>
<p>-spec update_rfc1123(binary(), undefined | calendar:datetime(),
    calendar:datetime()) -&gt; binary().
- <code>pad_int(X) when X &lt; 10 -&gt;
    &lt;&lt; $0, ($0 + X) &gt;&gt;;
pad_int(X)</code> - Following suggestion by MononcQc on #erlounge.
-spec pad_int(0..59) -&gt; binary().
- <code>update_rfc1123_test_()</code> - Tests.</p>
<p>-ifdef(TEST).</p>
<hr />
<h2 id="application-modules">Application Modules</h2>
<h3 id="cowboy_app">cowboy_app</h3>
<p><strong>File</strong>: <code>/Users/ddleon/.erlviz/cache/ninenines_cowboy/src/cowboy_app.erl</code></p>
<p><strong>Behaviors</strong>: application</p>
<p><strong>Description</strong>:
Copyright (c) Loïc Hoguin <a href="&#109;&#97;&#105;&#108;&#116;&#111;&#58;&#101;&#115;&#115;&#101;&#110;&#64;&#110;&#105;&#110;&#101;&#110;&#105;&#110;&#101;&#115;&#46;&#101;&#117;">&#101;&#115;&#115;&#101;&#110;&#64;&#110;&#105;&#110;&#101;&#110;&#105;&#110;&#101;&#115;&#46;&#101;&#117;</a>
%% Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted, provided that the above
copyright notice and this permission notice appear in all copies.
%% THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF</p>
<p><strong>Exported Functions</strong>: start/2, stop/1</p>
<p><strong>Functions</strong>:</p>
<ul>
<li><code>start(_, _)</code> - Copyright (c) Loïc Hoguin <a href="&#109;&#97;&#105;&#108;&#116;&#111;&#58;&#101;&#115;&#115;&#101;&#110;&#64;&#110;&#105;&#110;&#101;&#110;&#105;&#110;&#101;&#115;&#46;&#101;&#117;">&#101;&#115;&#115;&#101;&#110;&#64;&#110;&#105;&#110;&#101;&#110;&#105;&#110;&#101;&#115;&#46;&#101;&#117;</a>
%%
%% Permission to use, copy, modify, and/or distribute this software for any
%% purpose with or without fee is hereby granted, provided that the above
%% copyright notice and this permission notice appear in all copies.
%%
%% THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
%% WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
%% MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
%% ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
%% WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
%% ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
%% OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.</li>
</ul>
<p>-module(cowboy_app).
-behaviour(application).</p>
<p>-export([start/2]).
-export([stop/1]).</p>
<p>-spec start(<em>, </em>) -&gt; {ok, pid()}.</p>
<p><strong>Dependencies</strong>: cowboy_sup</p>
<hr />
    </div>
</body>
</html>